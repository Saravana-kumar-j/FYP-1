"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@assemblyscript";
exports.ids = ["vendor-chunks/@assemblyscript"];
exports.modules = {

/***/ "(ssr)/./node_modules/@assemblyscript/loader/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@assemblyscript/loader/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSxPQUFPO0FBQ2pCLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2QtbWFuZGF0ZXMvLi9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcz8yY2UyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBSdW50aW1lIGhlYWRlciBvZmZzZXRzXG5jb25zdCBJRF9PRkZTRVQgPSAtODtcbmNvbnN0IFNJWkVfT0ZGU0VUID0gLTQ7XG5cbi8vIFJ1bnRpbWUgaWRzXG5jb25zdCBBUlJBWUJVRkZFUl9JRCA9IDA7XG5jb25zdCBTVFJJTkdfSUQgPSAxO1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0lEID0gMjtcblxuLy8gUnVudGltZSB0eXBlIGluZm9ybWF0aW9uXG5jb25zdCBBUlJBWUJVRkZFUlZJRVcgPSAxIDw8IDA7XG5jb25zdCBBUlJBWSA9IDEgPDwgMTtcbmNvbnN0IFNFVCA9IDEgPDwgMjtcbmNvbnN0IE1BUCA9IDEgPDwgMztcbmNvbnN0IFZBTF9BTElHTl9PRkZTRVQgPSA1O1xuY29uc3QgVkFMX0FMSUdOID0gMSA8PCBWQUxfQUxJR05fT0ZGU0VUO1xuY29uc3QgVkFMX1NJR05FRCA9IDEgPDwgMTA7XG5jb25zdCBWQUxfRkxPQVQgPSAxIDw8IDExO1xuY29uc3QgVkFMX05VTExBQkxFID0gMSA8PCAxMjtcbmNvbnN0IFZBTF9NQU5BR0VEID0gMSA8PCAxMztcbmNvbnN0IEtFWV9BTElHTl9PRkZTRVQgPSAxNDtcbmNvbnN0IEtFWV9BTElHTiA9IDEgPDwgS0VZX0FMSUdOX09GRlNFVDtcbmNvbnN0IEtFWV9TSUdORUQgPSAxIDw8IDE5O1xuY29uc3QgS0VZX0ZMT0FUID0gMSA8PCAyMDtcbmNvbnN0IEtFWV9OVUxMQUJMRSA9IDEgPDwgMjE7XG5jb25zdCBLRVlfTUFOQUdFRCA9IDEgPDwgMjI7XG5cbi8vIEFycmF5KEJ1ZmZlclZpZXcpIGxheW91dFxuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0JVRkZFUl9PRkZTRVQgPSAwO1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPSA0O1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0RBVEFMRU5HVEhfT0ZGU0VUID0gODtcbmNvbnN0IEFSUkFZQlVGRkVSVklFV19TSVpFID0gMTI7XG5jb25zdCBBUlJBWV9MRU5HVEhfT0ZGU0VUID0gMTI7XG5jb25zdCBBUlJBWV9TSVpFID0gMTY7XG5cbmNvbnN0IEJJR0lOVCA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFRISVMgPSBTeW1ib2woKTtcbmNvbnN0IENIVU5LU0laRSA9IDEwMjQ7XG5cbi8qKiBHZXRzIGEgc3RyaW5nIGZyb20gYW4gVTMyIGFuZCBhbiBVMTYgdmlldyBvbiBhIG1lbW9yeS4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ0ltcGwoYnVmZmVyLCBwdHIpIHtcbiAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIGNvbnN0IFUxNiA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICB2YXIgbGVuZ3RoID0gVTMyWyhwdHIgKyBTSVpFX09GRlNFVCkgPj4+IDJdID4+PiAxO1xuICB2YXIgb2Zmc2V0ID0gcHRyID4+PiAxO1xuICBpZiAobGVuZ3RoIDw9IENIVU5LU0laRSkgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBVMTYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZG8ge1xuICAgIGNvbnN0IGxhc3QgPSBVMTZbb2Zmc2V0ICsgQ0hVTktTSVpFIC0gMV07XG4gICAgY29uc3Qgc2l6ZSA9IGxhc3QgPj0gMHhEODAwICYmIGxhc3QgPCAweERDMDAgPyBDSFVOS1NJWkUgLSAxIDogQ0hVTktTSVpFO1xuICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArPSBzaXplKSkpO1xuICAgIGxlbmd0aCAtPSBzaXplO1xuICB9IHdoaWxlIChsZW5ndGggPiBDSFVOS1NJWkUpO1xuICByZXR1cm4gcGFydHMuam9pbihcIlwiKSArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBVMTYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBiYXNlIG1vZHVsZSBwcmlvciB0byBpbnN0YW50aWF0aW9uLiAqL1xuZnVuY3Rpb24gcHJlSW5zdGFudGlhdGUoaW1wb3J0cykge1xuICBjb25zdCBiYXNlTW9kdWxlID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0U3RyaW5nKG1lbW9yeSwgcHRyKSB7XG4gICAgaWYgKCFtZW1vcnkpIHJldHVybiBcIjx5ZXQgdW5rbm93bj5cIjtcbiAgICByZXR1cm4gZ2V0U3RyaW5nSW1wbChtZW1vcnkuYnVmZmVyLCBwdHIpO1xuICB9XG5cbiAgLy8gYWRkIGNvbW1vbiBpbXBvcnRzIHVzZWQgYnkgc3RkbGliIGZvciBjb252ZW5pZW5jZVxuICBjb25zdCBlbnYgPSAoaW1wb3J0cy5lbnYgPSBpbXBvcnRzLmVudiB8fCB7fSk7XG4gIGVudi5hYm9ydCA9IGVudi5hYm9ydCB8fCBmdW5jdGlvbiBhYm9ydChtZXNnLCBmaWxlLCBsaW5lLCBjb2xtKSB7XG4gICAgY29uc3QgbWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgZW52Lm1lbW9yeTsgLy8gcHJlZmVyIGV4cG9ydGVkLCBvdGhlcndpc2UgdHJ5IGltcG9ydGVkXG4gICAgdGhyb3cgRXJyb3IoXCJhYm9ydDogXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBtZXNnKSArIFwiIGF0IFwiICsgZ2V0U3RyaW5nKG1lbW9yeSwgZmlsZSkgKyBcIjpcIiArIGxpbmUgKyBcIjpcIiArIGNvbG0pO1xuICB9XG4gIGVudi50cmFjZSA9IGVudi50cmFjZSB8fCBmdW5jdGlvbiB0cmFjZShtZXNnLCBuKSB7XG4gICAgY29uc3QgbWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgZW52Lm1lbW9yeTtcbiAgICBjb25zb2xlLmxvZyhcInRyYWNlOiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgKG4gPyBcIiBcIiA6IFwiXCIpICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyLCAyICsgbikuam9pbihcIiwgXCIpKTtcbiAgfVxuICBpbXBvcnRzLk1hdGggPSBpbXBvcnRzLk1hdGggfHwgTWF0aDtcbiAgaW1wb3J0cy5EYXRlID0gaW1wb3J0cy5EYXRlIHx8IERhdGU7XG5cbiAgcmV0dXJuIGJhc2VNb2R1bGU7XG59XG5cbi8qKiBQcmVwYXJlcyB0aGUgZmluYWwgbW9kdWxlIG9uY2UgaW5zdGFudGlhdGlvbiBpcyBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHBvc3RJbnN0YW50aWF0ZShiYXNlTW9kdWxlLCBpbnN0YW5jZSkge1xuICBjb25zdCByYXdFeHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgY29uc3QgbWVtb3J5ID0gcmF3RXhwb3J0cy5tZW1vcnk7XG4gIGNvbnN0IHRhYmxlID0gcmF3RXhwb3J0cy50YWJsZTtcbiAgY29uc3QgYWxsb2MgPSByYXdFeHBvcnRzW1wiX19hbGxvY1wiXTtcbiAgY29uc3QgcmV0YWluID0gcmF3RXhwb3J0c1tcIl9fcmV0YWluXCJdO1xuICBjb25zdCBydHRpQmFzZSA9IHJhd0V4cG9ydHNbXCJfX3J0dGlfYmFzZVwiXSB8fCB+MDsgLy8gb29iIGlmIG5vdCBwcmVzZW50XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgdHlwZSBpbmZvIGZvciB0aGUgZ2l2ZW4gaWQuICovXG4gIGZ1bmN0aW9uIGdldEluZm8oaWQpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgY29uc3QgY291bnQgPSBVMzJbcnR0aUJhc2UgPj4+IDJdO1xuICAgIGlmICgoaWQgPj4+PSAwKSA+PSBjb3VudCkgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGlkOiBcIiArIGlkKTtcbiAgICByZXR1cm4gVTMyWyhydHRpQmFzZSArIDQgPj4+IDIpICsgaWQgKiAyXTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGJhc2UgaWQgZm9yIHRoZSBnaXZlbiBpZC4gKi9cbiAgZnVuY3Rpb24gZ2V0QmFzZShpZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBjb3VudCA9IFUzMltydHRpQmFzZSA+Pj4gMl07XG4gICAgaWYgKChpZCA+Pj49IDApID49IGNvdW50KSB0aHJvdyBFcnJvcihcImludmFsaWQgaWQ6IFwiICsgaWQpO1xuICAgIHJldHVybiBVMzJbKHJ0dGlCYXNlICsgNCA+Pj4gMikgKyBpZCAqIDIgKyAxXTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGFsaWdubWVudCBvZiBhIGNvbGxlY3Rpb24ncyB2YWx1ZXMuICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlQWxpZ24oaW5mbykge1xuICAgIHJldHVybiAzMSAtIE1hdGguY2x6MzIoKGluZm8gPj4+IFZBTF9BTElHTl9PRkZTRVQpICYgMzEpOyAvLyAtMSBpZiBub25lXG4gIH1cblxuICAvKiogR2V0cyB0aGUgcnVudGltZSBhbGlnbm1lbnQgb2YgYSBjb2xsZWN0aW9uJ3Mga2V5cy4gKi9cbiAgZnVuY3Rpb24gZ2V0S2V5QWxpZ24oaW5mbykge1xuICAgIHJldHVybiAzMSAtIE1hdGguY2x6MzIoKGluZm8gPj4+IEtFWV9BTElHTl9PRkZTRVQpICYgMzEpOyAvLyAtMSBpZiBub25lXG4gIH1cblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IHN0cmluZyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5IGFuZCByZXR1cm5zIGl0cyByZXRhaW5lZCBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2FsbG9jU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgY29uc3QgcHRyID0gYWxsb2MobGVuZ3RoIDw8IDEsIFNUUklOR19JRCk7XG4gICAgY29uc3QgVTE2ID0gbmV3IFVpbnQxNkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBwID0gcHRyID4+PiAxOyBpIDwgbGVuZ3RoOyArK2kpIFUxNltwICsgaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gcHRyO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2FsbG9jU3RyaW5nID0gX19hbGxvY1N0cmluZztcblxuICAvKiogUmVhZHMgYSBzdHJpbmcgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5IGJ5IGl0cyBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2dldFN0cmluZyhwdHIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGNvbnN0IGlkID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcilbcHRyICsgSURfT0ZGU0VUID4+PiAyXTtcbiAgICBpZiAoaWQgIT09IFNUUklOR19JRCkgdGhyb3cgRXJyb3IoXCJub3QgYSBzdHJpbmc6IFwiICsgcHRyKTtcbiAgICByZXR1cm4gZ2V0U3RyaW5nSW1wbChidWZmZXIsIHB0cik7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0U3RyaW5nID0gX19nZXRTdHJpbmc7XG5cbiAgLyoqIEdldHMgdGhlIHZpZXcgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBhbGlnbm1lbnQsIHNpZ25lZG5lc3MgYW5kIGZsb2F0bmVzcy4gKi9cbiAgZnVuY3Rpb24gZ2V0VmlldyhhbGlnbkxvZzIsIHNpZ25lZCwgZmxvYXQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGlmIChmbG9hdCkge1xuICAgICAgc3dpdGNoIChhbGlnbkxvZzIpIHtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYWxpZ25Mb2cyKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyAoc2lnbmVkID8gSW50OEFycmF5IDogVWludDhBcnJheSkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQxNkFycmF5IDogVWludDE2QXJyYXkpKGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyAoc2lnbmVkID8gSW50MzJBcnJheSA6IFVpbnQzMkFycmF5KShidWZmZXIpO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgKHNpZ25lZCA/IEJpZ0ludDY0QXJyYXkgOiBCaWdVaW50NjRBcnJheSkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGlnbjogXCIgKyBhbGlnbkxvZzIpO1xuICB9XG5cbiAgLyoqIEFsbG9jYXRlcyBhIG5ldyBhcnJheSBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5IGFuZCByZXR1cm5zIGl0cyByZXRhaW5lZCBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2FsbG9jQXJyYXkoaWQsIHZhbHVlcykge1xuICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGlkKTtcbiAgICBpZiAoIShpbmZvICYgKEFSUkFZQlVGRkVSVklFVyB8IEFSUkFZKSkpIHRocm93IEVycm9yKFwibm90IGFuIGFycmF5OiBcIiArIGlkICsgXCIgQCBcIiArIGluZm8pO1xuICAgIGNvbnN0IGFsaWduID0gZ2V0VmFsdWVBbGlnbihpbmZvKTtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKGxlbmd0aCA8PCBhbGlnbiwgQVJSQVlCVUZGRVJfSUQpO1xuICAgIGNvbnN0IGFyciA9IGFsbG9jKGluZm8gJiBBUlJBWSA/IEFSUkFZX1NJWkUgOiBBUlJBWUJVRkZFUlZJRVdfU0laRSwgaWQpO1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0JVRkZFUl9PRkZTRVQgPj4+IDJdID0gcmV0YWluKGJ1Zik7XG4gICAgVTMyW2FyciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXSA9IGJ1ZjtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFMRU5HVEhfT0ZGU0VUID4+PiAyXSA9IGxlbmd0aCA8PCBhbGlnbjtcbiAgICBpZiAoaW5mbyAmIEFSUkFZKSBVMzJbYXJyICsgQVJSQVlfTEVOR1RIX09GRlNFVCA+Pj4gMl0gPSBsZW5ndGg7XG4gICAgY29uc3QgdmlldyA9IGdldFZpZXcoYWxpZ24sIGluZm8gJiBWQUxfU0lHTkVELCBpbmZvICYgVkFMX0ZMT0FUKTtcbiAgICBpZiAoaW5mbyAmIFZBTF9NQU5BR0VEKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB2aWV3WyhidWYgPj4+IGFsaWduKSArIGldID0gcmV0YWluKHZhbHVlc1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0KHZhbHVlcywgYnVmID4+PiBhbGlnbik7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fYWxsb2NBcnJheSA9IF9fYWxsb2NBcnJheTtcblxuICAvKiogR2V0cyBhIGxpdmUgdmlldyBvbiBhbiBhcnJheSdzIHZhbHVlcyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5LiBJbmZlcnMgdGhlIGFycmF5IHR5cGUgZnJvbSBSVFRJLiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5VmlldyhhcnIpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgY29uc3QgaWQgPSBVMzJbYXJyICsgSURfT0ZGU0VUID4+PiAyXTtcbiAgICBjb25zdCBpbmZvID0gZ2V0SW5mbyhpZCk7XG4gICAgaWYgKCEoaW5mbyAmIEFSUkFZQlVGRkVSVklFVykpIHRocm93IEVycm9yKFwibm90IGFuIGFycmF5OiBcIiArIGlkKTtcbiAgICBjb25zdCBhbGlnbiA9IGdldFZhbHVlQWxpZ24oaW5mbyk7XG4gICAgdmFyIGJ1ZiA9IFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfREFUQVNUQVJUX09GRlNFVCA+Pj4gMl07XG4gICAgY29uc3QgbGVuZ3RoID0gaW5mbyAmIEFSUkFZXG4gICAgICA/IFUzMlthcnIgKyBBUlJBWV9MRU5HVEhfT0ZGU0VUID4+PiAyXVxuICAgICAgOiBVMzJbYnVmICsgU0laRV9PRkZTRVQgPj4+IDJdID4+PiBhbGlnbjtcbiAgICByZXR1cm4gZ2V0VmlldyhhbGlnbiwgaW5mbyAmIFZBTF9TSUdORUQsIGluZm8gJiBWQUxfRkxPQVQpXG4gICAgICAgICAgLnN1YmFycmF5KGJ1ZiA+Pj49IGFsaWduLCBidWYgKyBsZW5ndGgpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5VmlldyA9IF9fZ2V0QXJyYXlWaWV3O1xuXG4gIC8qKiBDb3BpZXMgYW4gYXJyYXkncyB2YWx1ZXMgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiBJbmZlcnMgdGhlIGFycmF5IHR5cGUgZnJvbSBSVFRJLiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5KGFycikge1xuICAgIGNvbnN0IGlucHV0ID0gX19nZXRBcnJheVZpZXcoYXJyKTtcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgb3V0W2ldID0gaW5wdXRbaV07XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRBcnJheSA9IF9fZ2V0QXJyYXk7XG5cbiAgLyoqIENvcGllcyBhbiBBcnJheUJ1ZmZlcidzIHZhbHVlIGZyb20gdGhlIG1vZHVsZSdzIG1lbW9yeS4gKi9cbiAgZnVuY3Rpb24gX19nZXRBcnJheUJ1ZmZlcihwdHIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpW3B0ciArIFNJWkVfT0ZGU0VUID4+PiAyXTtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKHB0ciwgcHRyICsgbGVuZ3RoKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRBcnJheUJ1ZmZlciA9IF9fZ2V0QXJyYXlCdWZmZXI7XG5cbiAgLyoqIENvcGllcyBhIHR5cGVkIGFycmF5J3MgdmFsdWVzIGZyb20gdGhlIG1vZHVsZSdzIG1lbW9yeS4gKi9cbiAgZnVuY3Rpb24gZ2V0VHlwZWRBcnJheShUeXBlLCBhbGlnbkxvZzIsIHB0cikge1xuICAgIHJldHVybiBuZXcgVHlwZShnZXRUeXBlZEFycmF5VmlldyhUeXBlLCBhbGlnbkxvZzIsIHB0cikpO1xuICB9XG5cbiAgLyoqIEdldHMgYSBsaXZlIHZpZXcgb24gYSB0eXBlZCBhcnJheSdzIHZhbHVlcyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBnZXRUeXBlZEFycmF5VmlldyhUeXBlLCBhbGlnbkxvZzIsIHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgYnVmUHRyID0gVTMyW3B0ciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXTtcbiAgICByZXR1cm4gbmV3IFR5cGUoYnVmZmVyLCBidWZQdHIsIFUzMltidWZQdHIgKyBTSVpFX09GRlNFVCA+Pj4gMl0gPj4+IGFsaWduTG9nMik7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0SW50OEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDhBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQ4QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBVaW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4Q2xhbXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQ4Q2xhbXBlZEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4Q2xhbXBlZEFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDhDbGFtcGVkQXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MTZBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBJbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDE2QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQxNkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQxNkFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MzJBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBJbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQzMkFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDMyQXJyYXksIDIpO1xuICBpZiAoQklHSU5UKSB7XG4gICAgYmFzZU1vZHVsZS5fX2dldEludDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgQmlnSW50NjRBcnJheSwgMyk7XG4gICAgYmFzZU1vZHVsZS5fX2dldEludDY0QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBCaWdJbnQ2NEFycmF5LCAzKTtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0VWludDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgQmlnVWludDY0QXJyYXksIDMpO1xuICAgIGJhc2VNb2R1bGUuX19nZXRVaW50NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEJpZ1VpbnQ2NEFycmF5LCAzKTtcbiAgfVxuICBiYXNlTW9kdWxlLl9fZ2V0RmxvYXQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEZsb2F0MzJBcnJheSwgMik7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBGbG9hdDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0RmxvYXQ2NEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEZsb2F0NjRBcnJheSwgMyk7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDY0QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBGbG9hdDY0QXJyYXksIDMpO1xuXG4gIC8qKiBUZXN0cyB3aGV0aGVyIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgcmVwcmVzZW50ZWQgYnkgdGhlIHNwZWNpZmllZCBiYXNlIGlkLiAqL1xuICBmdW5jdGlvbiBfX2luc3RhbmNlb2YocHRyLCBiYXNlSWQpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgdmFyIGlkID0gVTMyWyhwdHIgKyBJRF9PRkZTRVQpID4+PiAyXTtcbiAgICBpZiAoaWQgPD0gVTMyW3J0dGlCYXNlID4+PiAyXSkge1xuICAgICAgZG8gaWYgKGlkID09IGJhc2VJZCkgcmV0dXJuIHRydWU7XG4gICAgICB3aGlsZSAoaWQgPSBnZXRCYXNlKGlkKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19pbnN0YW5jZW9mID0gX19pbnN0YW5jZW9mO1xuXG4gIC8vIFB1bGwgYmFzaWMgZXhwb3J0cyB0byBiYXNlTW9kdWxlIHNvIGNvZGUgaW4gcHJlSW5zdGFudGlhdGUgY2FuIHVzZSB0aGVtXG4gIGJhc2VNb2R1bGUubWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgbWVtb3J5O1xuICBiYXNlTW9kdWxlLnRhYmxlICA9IGJhc2VNb2R1bGUudGFibGUgIHx8IHRhYmxlO1xuXG4gIC8vIERlbWFuZ2xlIGV4cG9ydHMgYW5kIHByb3ZpZGUgdGhlIHVzdWFsIHV0aWxpdHkgb24gdGhlIHByb3RvdHlwZVxuICByZXR1cm4gZGVtYW5nbGUocmF3RXhwb3J0cywgYmFzZU1vZHVsZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVzcG9uc2Uobykge1xuICByZXR1cm4gdHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiICYmIG8gaW5zdGFuY2VvZiBSZXNwb25zZTtcbn1cblxuLyoqIEFzeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhbnl0aGluZyB0aGF0IGNhbiBiZSBpbnN0YW50aWF0ZWQuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZShzb3VyY2UsIGltcG9ydHMpIHtcbiAgaWYgKGlzUmVzcG9uc2Uoc291cmNlID0gYXdhaXQgc291cmNlKSkgcmV0dXJuIGluc3RhbnRpYXRlU3RyZWFtaW5nKHNvdXJjZSwgaW1wb3J0cyk7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoXG4gICAgICBzb3VyY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGVcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHNvdXJjZSksXG4gICAgICBpbXBvcnRzXG4gICAgKVxuICApO1xufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG5cbi8qKiBTeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIFdlYkFzc2VtYmx5Lk1vZHVsZSBvciBiaW5hcnkgYnVmZmVyLiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTeW5jKHNvdXJjZSwgaW1wb3J0cykge1xuICByZXR1cm4gcG9zdEluc3RhbnRpYXRlKFxuICAgIHByZUluc3RhbnRpYXRlKGltcG9ydHMgfHwgKGltcG9ydHMgPSB7fSkpLFxuICAgIG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoc291cmNlKSxcbiAgICAgIGltcG9ydHNcbiAgICApXG4gIClcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN5bmMgPSBpbnN0YW50aWF0ZVN5bmM7XG5cbi8qKiBBc3luY2hyb25vdXNseSBpbnN0YW50aWF0ZXMgYW4gQXNzZW1ibHlTY3JpcHQgbW9kdWxlIGZyb20gYSByZXNwb25zZSwgaS5lLiBhcyBvYnRhaW5lZCBieSBgZmV0Y2hgLiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKSB7XG4gIGlmICghV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpIHtcbiAgICByZXR1cm4gaW5zdGFudGlhdGUoXG4gICAgICBpc1Jlc3BvbnNlKHNvdXJjZSA9IGF3YWl0IHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICA6IHNvdXJjZSxcbiAgICAgIGltcG9ydHNcbiAgICApO1xuICB9XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgKGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHNvdXJjZSwgaW1wb3J0cykpLmluc3RhbmNlXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGVTdHJlYW1pbmcgPSBpbnN0YW50aWF0ZVN0cmVhbWluZztcblxuLyoqIERlbWFuZ2xlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUncyBleHBvcnRzIHRvIGEgZnJpZW5kbHkgb2JqZWN0IHN0cnVjdHVyZS4gKi9cbmZ1bmN0aW9uIGRlbWFuZ2xlKGV4cG9ydHMsIGJhc2VNb2R1bGUpIHtcbiAgdmFyIG1vZHVsZSA9IGJhc2VNb2R1bGUgPyBPYmplY3QuY3JlYXRlKGJhc2VNb2R1bGUpIDoge307XG4gIHZhciBzZXRBcmd1bWVudHNMZW5ndGggPSBleHBvcnRzW1wiX19hcmd1bWVudHNMZW5ndGhcIl1cbiAgICA/IGZ1bmN0aW9uKGxlbmd0aCkgeyBleHBvcnRzW1wiX19hcmd1bWVudHNMZW5ndGhcIl0udmFsdWUgPSBsZW5ndGg7IH1cbiAgICA6IGV4cG9ydHNbXCJfX3NldEFyZ3VtZW50c0xlbmd0aFwiXSB8fCBleHBvcnRzW1wiX19zZXRhcmdjXCJdIHx8IGZ1bmN0aW9uKCkge307XG4gIGZvciAobGV0IGludGVybmFsTmFtZSBpbiBleHBvcnRzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaW50ZXJuYWxOYW1lKSkgY29udGludWU7XG4gICAgY29uc3QgZWxlbSA9IGV4cG9ydHNbaW50ZXJuYWxOYW1lXTtcbiAgICBsZXQgcGFydHMgPSBpbnRlcm5hbE5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBjdXJyID0gbW9kdWxlO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyLCBwYXJ0KSkgY3VycltwYXJ0XSA9IHt9O1xuICAgICAgY3VyciA9IGN1cnJbcGFydF07XG4gICAgfVxuICAgIGxldCBuYW1lID0gcGFydHNbMF07XG4gICAgbGV0IGhhc2ggPSBuYW1lLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoID49IDApIHtcbiAgICAgIGxldCBjbGFzc05hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBoYXNoKTtcbiAgICAgIGxldCBjbGFzc0VsZW0gPSBjdXJyW2NsYXNzTmFtZV07XG4gICAgICBpZiAodHlwZW9mIGNsYXNzRWxlbSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY2xhc3NFbGVtLnByb3RvdHlwZSkge1xuICAgICAgICBsZXQgY3RvciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY3Rvci53cmFwKGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yKDAsIC4uLmFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1RISVNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3Rvci53cmFwID0gZnVuY3Rpb24odGhpc1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoY3Rvci5wcm90b3R5cGUsIHsgW1RISVNdOiB7IHZhbHVlOiB0aGlzVmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9IH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY2xhc3NFbGVtKSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjbGFzc0VsZW0pLmZvckVhY2gobmFtZSA9PlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBuYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNsYXNzRWxlbSwgbmFtZSkpXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJbY2xhc3NOYW1lXSA9IGN0b3I7XG4gICAgICB9XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaGFzaCArIDEpO1xuICAgICAgY3VyciA9IGN1cnJbY2xhc3NOYW1lXS5wcm90b3R5cGU7XG4gICAgICBpZiAoL14oZ2V0fHNldCk6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIG5hbWUgPSBuYW1lLnN1YnN0cmluZyg0KSkpIHtcbiAgICAgICAgICBsZXQgZ2V0dGVyID0gZXhwb3J0c1tpbnRlcm5hbE5hbWUucmVwbGFjZShcInNldDpcIiwgXCJnZXQ6XCIpXTtcbiAgICAgICAgICBsZXQgc2V0dGVyID0gZXhwb3J0c1tpbnRlcm5hbE5hbWUucmVwbGFjZShcImdldDpcIiwgXCJzZXQ6XCIpXTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VyciwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGdldHRlcih0aGlzW1RISVNdKTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgc2V0dGVyKHRoaXNbVEhJU10sIHZhbHVlKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAoY3VycltuYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0oLi4uYXJncyk7XG4gICAgICAgICAgfSkub3JpZ2luYWwgPSBlbGVtO1xuICAgICAgICB9IGVsc2UgeyAvLyBpbnN0YW5jZSBtZXRob2RcbiAgICAgICAgICAoY3VycltuYW1lXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHsgLy8gIVxuICAgICAgICAgICAgc2V0QXJndW1lbnRzTGVuZ3RoKGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtKHRoaXNbVEhJU10sIC4uLmFyZ3MpO1xuICAgICAgICAgIH0pLm9yaWdpbmFsID0gZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoL14oZ2V0fHNldCk6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIG5hbWUgPSBuYW1lLnN1YnN0cmluZyg0KSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VyciwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwic2V0OlwiLCBcImdldDpcIildLFxuICAgICAgICAgICAgc2V0OiBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwiZ2V0OlwiLCBcInNldDpcIildLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtID09PSBcImZ1bmN0aW9uXCIgJiYgZWxlbSAhPT0gc2V0QXJndW1lbnRzTGVuZ3RoKSB7XG4gICAgICAgIChjdXJyW25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBlbGVtKC4uLmFyZ3MpO1xuICAgICAgICB9KS5vcmlnaW5hbCA9IGVsZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyW25hbWVdID0gZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn1cblxuZXhwb3J0cy5kZW1hbmdsZSA9IGRlbWFuZ2xlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@assemblyscript/loader/index.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nft.storage";
exports.ids = ["vendor-chunks/nft.storage"];
exports.modules = {

/***/ "(ssr)/./node_modules/nft.storage/node_modules/@ipld/dag-cbor/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/@ipld/dag-cbor/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   code: () => (/* binding */ code),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ \"(ssr)/./node_modules/cborg/esm/cborg.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/esm/src/cid.js\");\n\n\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [\n    new cborg__WEBPACK_IMPORTED_MODULE_0__.Token(cborg__WEBPACK_IMPORTED_MODULE_0__.Type.tag, CID_CBOR_TAG),\n    new cborg__WEBPACK_IMPORTED_MODULE_0__.Token(cborg__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, bytes)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nconst name = 'dag-cbor';\nconst code = 113;\nconst encode = node => cborg__WEBPACK_IMPORTED_MODULE_0__.encode(node, encodeOptions);\nconst decode = data => cborg__WEBPACK_IMPORTED_MODULE_0__.decode(data, decodeOptions);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1jYm9yL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFXLENBQUMsdUNBQVU7QUFDOUIsUUFBUSx3Q0FBVyxDQUFDLHVDQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLFNBQVMsaURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0EsdUJBQXVCLHlDQUFZO0FBQ25DLHVCQUF1Qix5Q0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2QtbWFuZGF0ZXMvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1jYm9yL2VzbS9pbmRleC5qcz9lYmNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNib3JnIGZyb20gJ2Nib3JnJztcbmltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuY29uc3QgQ0lEX0NCT1JfVEFHID0gNDI7XG5mdW5jdGlvbiBjaWRFbmNvZGVyKG9iaikge1xuICBpZiAob2JqLmFzQ0lEICE9PSBvYmopIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjaWQgPSBDSUQuYXNDSUQob2JqKTtcbiAgaWYgKCFjaWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNpZC5ieXRlcy5ieXRlTGVuZ3RoICsgMSk7XG4gIGJ5dGVzLnNldChjaWQuYnl0ZXMsIDEpO1xuICByZXR1cm4gW1xuICAgIG5ldyBjYm9yZy5Ub2tlbihjYm9yZy5UeXBlLnRhZywgQ0lEX0NCT1JfVEFHKSxcbiAgICBuZXcgY2JvcmcuVG9rZW4oY2JvcmcuVHlwZS5ieXRlcywgYnl0ZXMpXG4gIF07XG59XG5mdW5jdGlvbiB1bmRlZmluZWRFbmNvZGVyKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2B1bmRlZmluZWRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbn1cbmZ1bmN0aW9uIG51bWJlckVuY29kZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNOYU4obnVtKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYE5hTmAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xuICB9XG4gIGlmIChudW0gPT09IEluZmluaXR5IHx8IG51bSA9PT0gLUluZmluaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgSW5maW5pdHlgIGFuZCBgLUluZmluaXR5YCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBlbmNvZGVPcHRpb25zID0ge1xuICBmbG9hdDY0OiB0cnVlLFxuICB0eXBlRW5jb2RlcnM6IHtcbiAgICBPYmplY3Q6IGNpZEVuY29kZXIsXG4gICAgdW5kZWZpbmVkOiB1bmRlZmluZWRFbmNvZGVyLFxuICAgIG51bWJlcjogbnVtYmVyRW5jb2RlclxuICB9XG59O1xuZnVuY3Rpb24gY2lkRGVjb2RlcihieXRlcykge1xuICBpZiAoYnl0ZXNbMF0gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0lEIGZvciBDQk9SIHRhZyA0MjsgZXhwZWN0ZWQgbGVhZGluZyAweDAwJyk7XG4gIH1cbiAgcmV0dXJuIENJRC5kZWNvZGUoYnl0ZXMuc3ViYXJyYXkoMSkpO1xufVxuY29uc3QgZGVjb2RlT3B0aW9ucyA9IHtcbiAgYWxsb3dJbmRlZmluaXRlOiBmYWxzZSxcbiAgYWxsb3dVbmRlZmluZWQ6IGZhbHNlLFxuICBhbGxvd05hTjogZmFsc2UsXG4gIGFsbG93SW5maW5pdHk6IGZhbHNlLFxuICBhbGxvd0JpZ0ludDogdHJ1ZSxcbiAgc3RyaWN0OiB0cnVlLFxuICB1c2VNYXBzOiBmYWxzZSxcbiAgdGFnczogW11cbn07XG5kZWNvZGVPcHRpb25zLnRhZ3NbQ0lEX0NCT1JfVEFHXSA9IGNpZERlY29kZXI7XG5leHBvcnQgY29uc3QgbmFtZSA9ICdkYWctY2Jvcic7XG5leHBvcnQgY29uc3QgY29kZSA9IDExMztcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBub2RlID0+IGNib3JnLmVuY29kZShub2RlLCBlbmNvZGVPcHRpb25zKTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSBkYXRhID0+IGNib3JnLmRlY29kZShkYXRhLCBkZWNvZGVPcHRpb25zKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/@ipld/dag-cbor/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/fs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/fs.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FsBlockStore: () => (/* binding */ FsBlockStore)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats */ \"(ssr)/./node_modules/multiformats/esm/src/index.js\");\n/* harmony import */ var blockstore_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blockstore-core */ \"(ssr)/./node_modules/blockstore-core/esm/src/index.js\");\n\n\n\n\nclass FsBlockStore extends blockstore_core__WEBPACK_IMPORTED_MODULE_3__.BaseBlockstore {\n    constructor() {\n        super();\n        this.path = `${os__WEBPACK_IMPORTED_MODULE_1__.tmpdir()}/${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`;\n        this._opened = false;\n    }\n    async _open() {\n        if (this._opening) {\n            await this._opening;\n        }\n        else {\n            this._opening = fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(this.path);\n            await this._opening;\n            this._opened = true;\n        }\n    }\n    async put(cid, bytes) {\n        if (!this._opened) {\n            await this._open();\n        }\n        const cidStr = cid.toString();\n        const location = `${this.path}/${cidStr}`;\n        await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(location, bytes);\n    }\n    async get(cid) {\n        if (!this._opened) {\n            await this._open();\n        }\n        const cidStr = cid.toString();\n        const location = `${this.path}/${cidStr}`;\n        const bytes = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(location);\n        return bytes;\n    }\n    async has(cid) {\n        if (!this._opened) {\n            await this._open();\n        }\n        const cidStr = cid.toString();\n        const location = `${this.path}/${cidStr}`;\n        try {\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.access(location);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    async *blocks() {\n        if (!this._opened) {\n            await this._open();\n        }\n        const cids = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readdir(this.path);\n        for (const cidStr of cids) {\n            const location = `${this.path}/${cidStr}`;\n            const bytes = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(location);\n            yield { cid: multiformats__WEBPACK_IMPORTED_MODULE_2__.CID.parse(cidStr), bytes };\n        }\n    }\n    async close() {\n        if (this._opened) {\n            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.rm(this.path, { recursive: true });\n        }\n        this._opened = false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL2Jsb2Nrc3RvcmUvZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0I7QUFDQTtBQUNlO0FBQ2M7QUFDMUMsMkJBQTJCLDJEQUFjO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQVMsR0FBRyxHQUFHLG9FQUFvRTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSxHQUFHLE9BQU87QUFDaEQsY0FBYyx3Q0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSxHQUFHLE9BQU87QUFDaEQsNEJBQTRCLHdDQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsR0FBRyxPQUFPO0FBQ2hEO0FBQ0Esa0JBQWtCLHdDQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdDQUFXO0FBQ3RDO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyxPQUFPO0FBQ3BELGdDQUFnQyx3Q0FBVztBQUMzQyxvQkFBb0IsS0FBSyw2Q0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3Q0FBVyxpQkFBaUIsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZC1tYW5kYXRlcy8uL25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9ub2RlX21vZHVsZXMvaXBmcy1jYXIvZGlzdC9lc20vYmxvY2tzdG9yZS9mcy5qcz81N2E3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzJztcbmltcG9ydCB7IEJhc2VCbG9ja3N0b3JlIH0gZnJvbSAnYmxvY2tzdG9yZS1jb3JlJztcbmV4cG9ydCBjbGFzcyBGc0Jsb2NrU3RvcmUgZXh0ZW5kcyBCYXNlQmxvY2tzdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IGAke29zLnRtcGRpcigpfS8keyhwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIDFlOSksIDEwKSkudG9TdHJpbmcoKSArIERhdGUubm93KCl9YDtcbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIF9vcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fb3BlbmluZykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb3BlbmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5pbmcgPSBmcy5wcm9taXNlcy5ta2Rpcih0aGlzLnBhdGgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb3BlbmluZztcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHV0KGNpZCwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjaWQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShsb2NhdGlvbiwgYnl0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBnZXQoY2lkKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkU3RyID0gY2lkLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gYCR7dGhpcy5wYXRofS8ke2NpZFN0cn1gO1xuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGxvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBhc3luYyBoYXMoY2lkKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkU3RyID0gY2lkLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gYCR7dGhpcy5wYXRofS8ke2NpZFN0cn1gO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMuYWNjZXNzKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqYmxvY2tzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpZHMgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkZGlyKHRoaXMucGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgY2lkU3RyIG9mIGNpZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gYCR7dGhpcy5wYXRofS8ke2NpZFN0cn1gO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShsb2NhdGlvbik7XG4gICAgICAgICAgICB5aWVsZCB7IGNpZDogQ0lELnBhcnNlKGNpZFN0ciksIGJ5dGVzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLnJtKHRoaXMucGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/fs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/memory.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/memory.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MemoryBlockStore: () => (/* binding */ MemoryBlockStore)\n/* harmony export */ });\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats */ \"(ssr)/./node_modules/multiformats/esm/src/index.js\");\n/* harmony import */ var blockstore_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blockstore-core */ \"(ssr)/./node_modules/blockstore-core/esm/src/index.js\");\n\n\nclass MemoryBlockStore extends blockstore_core__WEBPACK_IMPORTED_MODULE_1__.BaseBlockstore {\n    constructor() {\n        super();\n        this.store = new Map();\n    }\n    async *blocks() {\n        for (const [cidStr, bytes] of this.store.entries()) {\n            yield { cid: multiformats__WEBPACK_IMPORTED_MODULE_0__.CID.parse(cidStr), bytes };\n        }\n    }\n    put(cid, bytes) {\n        this.store.set(cid.toString(), bytes);\n        return Promise.resolve();\n    }\n    get(cid) {\n        const bytes = this.store.get(cid.toString());\n        if (!bytes) {\n            throw new Error(`block with cid ${cid.toString()} no found`);\n        }\n        return Promise.resolve(bytes);\n    }\n    has(cid) {\n        return Promise.resolve(this.store.has(cid.toString()));\n    }\n    close() {\n        this.store.clear();\n        return Promise.resolve();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL2Jsb2Nrc3RvcmUvbWVtb3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtQztBQUNjO0FBQzFDLCtCQUErQiwyREFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyw2Q0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kLW1hbmRhdGVzLy4vbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL25vZGVfbW9kdWxlcy9pcGZzLWNhci9kaXN0L2VzbS9ibG9ja3N0b3JlL21lbW9yeS5qcz80YTM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgeyBCYXNlQmxvY2tzdG9yZSB9IGZyb20gJ2Jsb2Nrc3RvcmUtY29yZSc7XG5leHBvcnQgY2xhc3MgTWVtb3J5QmxvY2tTdG9yZSBleHRlbmRzIEJhc2VCbG9ja3N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgKmJsb2NrcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2lkU3RyLCBieXRlc10gb2YgdGhpcy5zdG9yZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgY2lkOiBDSUQucGFyc2UoY2lkU3RyKSwgYnl0ZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQoY2lkLCBieXRlcykge1xuICAgICAgICB0aGlzLnN0b3JlLnNldChjaWQudG9TdHJpbmcoKSwgYnl0ZXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldChjaWQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0b3JlLmdldChjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmxvY2sgd2l0aCBjaWQgJHtjaWQudG9TdHJpbmcoKX0gbm8gZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ5dGVzKTtcbiAgICB9XG4gICAgaGFzKGNpZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3RvcmUuaGFzKGNpZC50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/memory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unixfsImporterOptionsDefault: () => (/* binding */ unixfsImporterOptionsDefault)\n/* harmony export */ });\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"(ssr)/./node_modules/multiformats/esm/src/hashes/sha2.js\");\n\nconst unixfsImporterOptionsDefault = {\n    cidVersion: 1,\n    chunker: 'fixed',\n    maxChunkSize: 262144,\n    hasher: multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_0__.sha256,\n    rawLeaves: true,\n    wrapWithDirectory: true,\n    maxChildrenPerNode: 174\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEO0FBQzNDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2QtbWFuZGF0ZXMvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svY29uc3RhbnRzLmpzPzU5ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmV4cG9ydCBjb25zdCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0ID0ge1xuICAgIGNpZFZlcnNpb246IDEsXG4gICAgY2h1bmtlcjogJ2ZpeGVkJyxcbiAgICBtYXhDaHVua1NpemU6IDI2MjE0NCxcbiAgICBoYXNoZXI6IHNoYTI1NixcbiAgICByYXdMZWF2ZXM6IHRydWUsXG4gICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgbWF4Q2hpbGRyZW5QZXJOb2RlOiAxNzRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pack: () => (/* binding */ pack)\n/* harmony export */ });\n/* harmony import */ var it_last__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! it-last */ \"(ssr)/./node_modules/it-last/index.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! it-pipe */ \"(ssr)/./node_modules/it-pipe/index.js\");\n/* harmony import */ var _ipld_car__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ipld/car */ \"(ssr)/./node_modules/@ipld/car/esm/car.js\");\n/* harmony import */ var ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-unixfs-importer */ \"(ssr)/./node_modules/ipfs-unixfs-importer/esm/src/index.js\");\n/* harmony import */ var _utils_normalise_input_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/normalise-input.js */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js\");\n/* harmony import */ var _blockstore_memory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../blockstore/memory.js */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/memory.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/constants.js\");\n\n\n\n\n\n\n\nasync function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new _blockstore_memory_js__WEBPACK_IMPORTED_MODULE_5__.MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await it_last__WEBPACK_IMPORTED_MODULE_0__(it_pipe__WEBPACK_IMPORTED_MODULE_1__((0,_utils_normalise_input_js__WEBPACK_IMPORTED_MODULE_4__.getNormaliser)(input), (source) => (0,ipfs_unixfs_importer__WEBPACK_IMPORTED_MODULE_3__.importer)(source, blockstore, {\n        ..._constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault,\n        hasher: hasher || _constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || _constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || _constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : _constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? _constants_js__WEBPACK_IMPORTED_MODULE_6__.unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await _ipld_car__WEBPACK_IMPORTED_MODULE_2__.CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkI7QUFDQTtBQUNXO0FBQ1U7QUFDVztBQUNBO0FBQ0c7QUFDdkQsc0JBQXNCLDJHQUEyRztBQUN4STtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUVBQWdCO0FBQzdFO0FBQ0EsNEJBQTRCLG9DQUFJLENBQUMsb0NBQUksQ0FBQyx3RUFBYSxxQkFBcUIsOERBQVE7QUFDaEYsV0FBVyx1RUFBNEI7QUFDdkMsMEJBQTBCLHVFQUE0QjtBQUN0RCxzQ0FBc0MsdUVBQTRCO0FBQ2xFLGtEQUFrRCx1RUFBNEI7QUFDOUUsaUVBQWlFLHVFQUE0QjtBQUM3Rix1Q0FBdUMsdUVBQTRCO0FBQ25FLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCLFFBQVEsZ0RBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2QtbWFuZGF0ZXMvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svaW5kZXguanM/YjhlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbGFzdCBmcm9tICdpdC1sYXN0JztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IHsgQ2FyV3JpdGVyIH0gZnJvbSAnQGlwbGQvY2FyJztcbmltcG9ydCB7IGltcG9ydGVyIH0gZnJvbSAnaXBmcy11bml4ZnMtaW1wb3J0ZXInO1xuaW1wb3J0IHsgZ2V0Tm9ybWFsaXNlciB9IGZyb20gXCIuL3V0aWxzL25vcm1hbGlzZS1pbnB1dC5qc1wiO1xuaW1wb3J0IHsgTWVtb3J5QmxvY2tTdG9yZSB9IGZyb20gXCIuLi9ibG9ja3N0b3JlL21lbW9yeS5qc1wiO1xuaW1wb3J0IHsgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdCB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhY2soeyBpbnB1dCwgYmxvY2tzdG9yZTogdXNlckJsb2Nrc3RvcmUsIGhhc2hlciwgbWF4Q2h1bmtTaXplLCBtYXhDaGlsZHJlblBlck5vZGUsIHdyYXBXaXRoRGlyZWN0b3J5LCByYXdMZWF2ZXMgfSkge1xuICAgIGlmICghaW5wdXQgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmICFpbnB1dC5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbnB1dCBmaWxlKHMpJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSB1c2VyQmxvY2tzdG9yZSA/IHVzZXJCbG9ja3N0b3JlIDogbmV3IE1lbW9yeUJsb2NrU3RvcmUoKTtcbiAgICAvLyBDb25zdW1lIHRoZSBzb3VyY2VcbiAgICBjb25zdCByb290RW50cnkgPSBhd2FpdCBsYXN0KHBpcGUoZ2V0Tm9ybWFsaXNlcihpbnB1dCksIChzb3VyY2UpID0+IGltcG9ydGVyKHNvdXJjZSwgYmxvY2tzdG9yZSwge1xuICAgICAgICAuLi51bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LFxuICAgICAgICBoYXNoZXI6IGhhc2hlciB8fCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0Lmhhc2hlcixcbiAgICAgICAgbWF4Q2h1bmtTaXplOiBtYXhDaHVua1NpemUgfHwgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5tYXhDaHVua1NpemUsXG4gICAgICAgIG1heENoaWxkcmVuUGVyTm9kZTogbWF4Q2hpbGRyZW5QZXJOb2RlIHx8IHVuaXhmc0ltcG9ydGVyT3B0aW9uc0RlZmF1bHQubWF4Q2hpbGRyZW5QZXJOb2RlLFxuICAgICAgICB3cmFwV2l0aERpcmVjdG9yeTogd3JhcFdpdGhEaXJlY3RvcnkgPT09IGZhbHNlID8gZmFsc2UgOiB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LndyYXBXaXRoRGlyZWN0b3J5LFxuICAgICAgICByYXdMZWF2ZXM6IHJhd0xlYXZlcyA9PSBudWxsID8gdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5yYXdMZWF2ZXMgOiByYXdMZWF2ZXNcbiAgICB9KSkpO1xuICAgIGlmICghcm9vdEVudHJ5IHx8ICFyb290RW50cnkuY2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2l2ZW4gaW5wdXQgY291bGQgbm90IGJlIHBhcnNlZCBjb3JyZWN0bHknKTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHJvb3RFbnRyeS5jaWQ7XG4gICAgY29uc3QgeyB3cml0ZXIsIG91dDogY2FyT3V0IH0gPSBhd2FpdCBDYXJXcml0ZXIuY3JlYXRlKFtyb290XSk7XG4gICAgY29uc3QgY2FyT3V0SXRlciA9IGNhck91dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgd3JpdGluZ1Byb21pc2U7XG4gICAgY29uc3Qgd3JpdGVBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgYmxvY2tzdG9yZS5ibG9ja3MoKSkge1xuICAgICAgICAgICAgLy8gYGF3YWl0YCB3aWxsIGJsb2NrIHVudGlsIGFsbCBieXRlcyBpbiBgY2FyT3V0YCBhcmUgY29uc3VtZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgYmFja3ByZXNzdXJlIGhlcmVcbiAgICAgICAgICAgIGF3YWl0IHdyaXRlci5wdXQoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgICAgICBpZiAoIXVzZXJCbG9ja3N0b3JlKSB7XG4gICAgICAgICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGlmICh3cml0aW5nUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBpdGVyYXRvciBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBzdGFydCB3cml0aW5nIHVudGlsIHRoZSB1c2VyIHN0YXJ0cyBjb25zdW1pbmcgdGhlIGl0ZXJhdG9yXG4gICAgICAgICAgICB3cml0aW5nUHJvbWlzZSA9IHdyaXRlQWxsKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhck91dEl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRpbmdQcm9taXNlOyAvLyBhbnkgZXJyb3JzIHdpbGwgcHJvcGFnYXRlIGZyb20gaGVyZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcm9vdCwgb3V0IH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNormaliser: () => (/* binding */ getNormaliser)\n/* harmony export */ });\n/* harmony import */ var ipfs_core_utils_files_normalise_input_single__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-core-utils/files/normalise-input-single */ \"(ssr)/./node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js\");\n/* harmony import */ var ipfs_core_utils_files_normalise_input_multiple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ipfs-core-utils/files/normalise-input-multiple */ \"(ssr)/./node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js\");\n\n\nfunction isBytes(obj) {\n    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nfunction isBlob(obj) {\n    return Boolean(obj.constructor) &&\n        (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&\n        typeof obj.stream === 'function';\n}\nfunction isSingle(input) {\n    return typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || '_readableState' in input;\n}\n/**\n * Get a single or multiple normaliser depending on the input.\n */\nfunction getNormaliser(input) {\n    if (isSingle(input)) {\n        return (0,ipfs_core_utils_files_normalise_input_single__WEBPACK_IMPORTED_MODULE_0__.normaliseInput)(input);\n    }\n    else {\n        return (0,ipfs_core_utils_files_normalise_input_multiple__WEBPACK_IMPORTED_MODULE_1__.normaliseInput)(input);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svdXRpbHMvbm9ybWFsaXNlLWlucHV0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRztBQUNJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw0RkFBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUsOEZBQXNCO0FBQ3JDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kLW1hbmRhdGVzLy4vbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL25vZGVfbW9kdWxlcy9pcGZzLWNhci9kaXN0L2VzbS9wYWNrL3V0aWxzL25vcm1hbGlzZS1pbnB1dC5qcz9lZjgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vcm1hbGlzZUlucHV0IGFzIG5vcm1hbGlzZUlucHV0U2luZ2xlIH0gZnJvbSAnaXBmcy1jb3JlLXV0aWxzL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC1zaW5nbGUnO1xuaW1wb3J0IHsgbm9ybWFsaXNlSW5wdXQgYXMgbm9ybWFsaXNlSW5wdXRNdWx0aXBsZSB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtbXVsdGlwbGUnO1xuZnVuY3Rpb24gaXNCeXRlcyhvYmopIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgfHwgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5mdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob2JqLmNvbnN0cnVjdG9yKSAmJlxuICAgICAgICAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCbG9iJyB8fCBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0ZpbGUnKSAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgaXNCeXRlcyhpbnB1dCkgfHwgaXNCbG9iKGlucHV0KSB8fCAnX3JlYWRhYmxlU3RhdGUnIGluIGlucHV0O1xufVxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgb3IgbXVsdGlwbGUgbm9ybWFsaXNlciBkZXBlbmRpbmcgb24gdGhlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9ybWFsaXNlcihpbnB1dCkge1xuICAgIGlmIChpc1NpbmdsZShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGlzZUlucHV0U2luZ2xlKGlucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpc2VJbnB1dE11bHRpcGxlKGlucHV0KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/bs-car-reader.js":
/*!*******************************************************!*\
  !*** ./node_modules/nft.storage/src/bs-car-reader.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockstoreCarReader: () => (/* binding */ BlockstoreCarReader)\n/* harmony export */ });\n/**\n * An implementation of the CAR reader interface that is backed by a blockstore.\n *\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@ipld/car/api').CarReader} CarReader\n * @implements {CarReader}\n */\nclass BlockstoreCarReader {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {import('ipfs-car/blockstore').Blockstore} blockstore\n   */\n  constructor(version, roots, blockstore) {\n    /**\n     * @private\n     */\n    this._version = version\n    /**\n     * @private\n     */\n    this._roots = roots\n    /**\n     * @private\n     */\n    this._blockstore = blockstore\n  }\n\n  get version() {\n    return this._version\n  }\n\n  get blockstore() {\n    return this._blockstore\n  }\n\n  async getRoots() {\n    return this._roots\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  has(cid) {\n    return this._blockstore.has(cid)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  async get(cid) {\n    const bytes = await this._blockstore.get(cid)\n    return { cid, bytes }\n  }\n\n  blocks() {\n    return this._blockstore.blocks()\n  }\n\n  async *cids() {\n    for await (const b of this.blocks()) {\n      yield b.cid\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2JzLWNhci1yZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsbUNBQW1DO0FBQ2hELGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2QtbWFuZGF0ZXMvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2JzLWNhci1yZWFkZXIuanM/YTU5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDQVIgcmVhZGVyIGludGVyZmFjZSB0aGF0IGlzIGJhY2tlZCBieSBhIGJsb2Nrc3RvcmUuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbXVsdGlmb3JtYXRzJykuQ0lEfSBDSURcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ0BpcGxkL2Nhci9hcGknKS5DYXJSZWFkZXJ9IENhclJlYWRlclxuICogQGltcGxlbWVudHMge0NhclJlYWRlcn1cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2Nrc3RvcmVDYXJSZWFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb25cbiAgICogQHBhcmFtIHtDSURbXX0gcm9vdHNcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBibG9ja3N0b3JlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCByb290cywgYmxvY2tzdG9yZSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb25cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHNcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Jsb2Nrc3RvcmUgPSBibG9ja3N0b3JlXG4gIH1cblxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvblxuICB9XG5cbiAgZ2V0IGJsb2Nrc3RvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc3RvcmVcbiAgfVxuXG4gIGFzeW5jIGdldFJvb3RzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAgICovXG4gIGhhcyhjaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzdG9yZS5oYXMoY2lkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q0lEfSBjaWRcbiAgICovXG4gIGFzeW5jIGdldChjaWQpIHtcbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IHRoaXMuX2Jsb2Nrc3RvcmUuZ2V0KGNpZClcbiAgICByZXR1cm4geyBjaWQsIGJ5dGVzIH1cbiAgfVxuXG4gIGJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzdG9yZS5ibG9ja3MoKVxuICB9XG5cbiAgYXN5bmMgKmNpZHMoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHRoaXMuYmxvY2tzKCkpIHtcbiAgICAgIHlpZWxkIGIuY2lkXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/gateway.js":
/*!*************************************************!*\
  !*** ./node_modules/nft.storage/src/gateway.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GATEWAY: () => (/* binding */ GATEWAY),\n/* harmony export */   toGatewayURL: () => (/* binding */ toGatewayURL)\n/* harmony export */ });\nconst GATEWAY = new URL('https://nftstorage.link/')\n\n/**\n * @typedef {string|URL} GatewayURL Base URL of an IPFS Gateway e.g. https://dweb.link/ or https://ipfs.io/\n * @typedef {{ gateway?: GatewayURL }} GatewayURLOptions\n */\n\n/**\n * Convert an IPFS URL (starting ipfs://) to a gateway URL (starting https://)\n * that can be used in a webpage. If the passed URL is not an IPFS URL it is\n * returned as a new URL object with no further changes.\n *\n * @param {string|URL} url An IPFS URL e.g. ipfs://bafy.../path\n * @param {GatewayURLOptions} [options] Options that allow customization of the gateway used.\n * @returns {URL} An IPFS gateway URL e.g. https://nftstorage.link/ipfs/bafy.../path\n */\nconst toGatewayURL = (url, options = {}) => {\n  const gateway = options.gateway || GATEWAY\n  url = new URL(String(url))\n  return url.protocol === 'ipfs:'\n    ? new URL(`/ipfs/${url.href.slice('ipfs://'.length)}`, gateway)\n    : url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2dhdGV3YXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTzs7QUFFUDtBQUNBLGFBQWEsWUFBWTtBQUN6QixlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsS0FBSztBQUNsQjtBQUNPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kLW1hbmRhdGVzLy4vbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9nYXRld2F5LmpzP2FhY2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEdBVEVXQVkgPSBuZXcgVVJMKCdodHRwczovL25mdHN0b3JhZ2UubGluay8nKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd8VVJMfSBHYXRld2F5VVJMIEJhc2UgVVJMIG9mIGFuIElQRlMgR2F0ZXdheSBlLmcuIGh0dHBzOi8vZHdlYi5saW5rLyBvciBodHRwczovL2lwZnMuaW8vXG4gKiBAdHlwZWRlZiB7eyBnYXRld2F5PzogR2F0ZXdheVVSTCB9fSBHYXRld2F5VVJMT3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29udmVydCBhbiBJUEZTIFVSTCAoc3RhcnRpbmcgaXBmczovLykgdG8gYSBnYXRld2F5IFVSTCAoc3RhcnRpbmcgaHR0cHM6Ly8pXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgd2VicGFnZS4gSWYgdGhlIHBhc3NlZCBVUkwgaXMgbm90IGFuIElQRlMgVVJMIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBhIG5ldyBVUkwgb2JqZWN0IHdpdGggbm8gZnVydGhlciBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gdXJsIEFuIElQRlMgVVJMIGUuZy4gaXBmczovL2JhZnkuLi4vcGF0aFxuICogQHBhcmFtIHtHYXRld2F5VVJMT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdGhhdCBhbGxvdyBjdXN0b21pemF0aW9uIG9mIHRoZSBnYXRld2F5IHVzZWQuXG4gKiBAcmV0dXJucyB7VVJMfSBBbiBJUEZTIGdhdGV3YXkgVVJMIGUuZy4gaHR0cHM6Ly9uZnRzdG9yYWdlLmxpbmsvaXBmcy9iYWZ5Li4uL3BhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IHRvR2F0ZXdheVVSTCA9ICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBnYXRld2F5ID0gb3B0aW9ucy5nYXRld2F5IHx8IEdBVEVXQVlcbiAgdXJsID0gbmV3IFVSTChTdHJpbmcodXJsKSlcbiAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gJ2lwZnM6J1xuICAgID8gbmV3IFVSTChgL2lwZnMvJHt1cmwuaHJlZi5zbGljZSgnaXBmczovLycubGVuZ3RoKX1gLCBnYXRld2F5KVxuICAgIDogdXJsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/gateway.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/lib.js":
/*!*********************************************!*\
  !*** ./node_modules/nft.storage/src/lib.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob),\n/* harmony export */   File: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_7__.FormData),\n/* harmony export */   NFTStorage: () => (/* binding */ NFTStorage),\n/* harmony export */   Token: () => (/* reexport module object */ _token_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   createRateLimiter: () => (/* binding */ createRateLimiter),\n/* harmony export */   toAsyncIterable: () => (/* binding */ toAsyncIterable),\n/* harmony export */   toGatewayURL: () => (/* reexport safe */ _gateway_js__WEBPACK_IMPORTED_MODULE_8__.toGatewayURL)\n/* harmony export */ });\n/* harmony import */ var streaming_iterables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! streaming-iterables */ \"(ssr)/./node_modules/streaming-iterables/dist/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-retry */ \"(ssr)/./node_modules/p-retry/index.js\");\n/* harmony import */ var carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! carbites/treewalk */ \"(ssr)/./node_modules/carbites/esm/lib/treewalk/index.js\");\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/pack */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var throttled_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttled-queue */ \"(ssr)/./node_modules/throttled-queue/dist/throttledQueue.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./token.js */ \"(ssr)/./node_modules/nft.storage/src/token.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./platform.js */ \"(ssr)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gateway.js */ \"(ssr)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\");\n/* harmony import */ var it_pipe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! it-pipe */ \"(ssr)/./node_modules/it-pipe/index.js\");\n/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nfunction createRateLimiter() {\n  const throttle = throttled_queue__WEBPACK_IMPORTED_MODULE_5__(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = {\n      ...NFTStorage.auth(token),\n      'Content-Type': 'application/car',\n    }\n    const targetSize = maxChunkSize || MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob\n        ? await carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new carbites_treewalk__WEBPACK_IMPORTED_MODULE_2__.TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = (0,streaming_iterables__WEBPACK_IMPORTED_MODULE_0__.transform)(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob(carParts, { type: 'application/car' })\n        /** @type {Blob|ArrayBuffer} */\n        let body = carFile\n        // FIXME: should not be necessary to await arrayBuffer()!\n        // Node.js 20 hangs reading the stream (it never ends) but in\n        // older node versions and the browser it is fine to pass a blob.\n        /* c8 ignore next 3 */\n        if (parseInt(globalThis.process?.versions?.node) > 18) {\n          body = await body.arrayBuffer()\n        }\n        const cid = await p_retry__WEBPACK_IMPORTED_MODULE_1__(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n                method: 'POST',\n                headers,\n                body,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await (0,_platform_js__WEBPACK_IMPORTED_MODULE_7__.fetch)(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return _token_js__WEBPACK_IMPORTED_MODULE_6__.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = it_pipe__WEBPACK_IMPORTED_MODULE_10__(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nfunction toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new _platform_js__WEBPACK_IMPORTED_MODULE_7__.Blockstore()\n  const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_3__.pack)({ input, blockstore, wrapWithDirectory })\n  const car = new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_9__.BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDSDtBQUNXO0FBQ25CO0FBQ0U7QUFDTTtBQUNUO0FBQ29DO0FBQzVCO0FBQ2E7QUFDOUI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDZDQUE2QztBQUMxRDs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsbUJBQW1CLDRDQUFjO0FBQ2pDLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxhQUFhLHVDQUF1QztBQUNwRDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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cmMvbGliLmpzPzk0NzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGNsaWVudCBsaWJyYXJ5IGZvciB0aGUgaHR0cHM6Ly9uZnQuc3RvcmFnZS8gc2VydmljZS4gSXQgcHJvdmlkZXMgYSBjb252ZW5pZW50XG4gKiBpbnRlcmZhY2UgZm9yIHdvcmtpbmcgd2l0aCB0aGUgW1JhdyBIVFRQIEFQSV0oaHR0cHM6Ly9uZnQuc3RvcmFnZS8jYXBpLWRvY3MpXG4gKiBmcm9tIGEgd2ViIGJyb3dzZXIgb3IgW05vZGUuanNdKGh0dHBzOi8vbm9kZWpzLm9yZy8pIGFuZCBjb21lcyBidW5kbGVkIHdpdGhcbiAqIFRTIGZvciBvdXQtb2YtdGhlIGJveCB0eXBlIGluZmVyZW5jZSBhbmQgYmV0dGVyIEludGVsbGlTZW5zZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IE5GVFN0b3JhZ2UsIEZpbGUsIEJsb2IgfSBmcm9tIFwibmZ0LnN0b3JhZ2VcIlxuICogY29uc3QgY2xpZW50ID0gbmV3IE5GVFN0b3JhZ2UoeyB0b2tlbjogQVBJX1RPS0VOIH0pXG4gKlxuICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlQmxvYihuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pKVxuICogYGBgXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0IHsgdHJhbnNmb3JtIH0gZnJvbSAnc3RyZWFtaW5nLWl0ZXJhYmxlcydcbmltcG9ydCBwUmV0cnksIHsgQWJvcnRFcnJvciB9IGZyb20gJ3AtcmV0cnknXG5pbXBvcnQgeyBUcmVld2Fsa0NhclNwbGl0dGVyIH0gZnJvbSAnY2FyYml0ZXMvdHJlZXdhbGsnXG5pbXBvcnQgeyBwYWNrIH0gZnJvbSAnaXBmcy1jYXIvcGFjaydcbmltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgdGhyb3R0bGVkUXVldWUgZnJvbSAndGhyb3R0bGVkLXF1ZXVlJ1xuaW1wb3J0ICogYXMgVG9rZW4gZnJvbSAnLi90b2tlbi5qcydcbmltcG9ydCB7IGZldGNoLCBGaWxlLCBCbG9iLCBGb3JtRGF0YSwgQmxvY2tzdG9yZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnXG5pbXBvcnQgeyB0b0dhdGV3YXlVUkwgfSBmcm9tICcuL2dhdGV3YXkuanMnXG5pbXBvcnQgeyBCbG9ja3N0b3JlQ2FyUmVhZGVyIH0gZnJvbSAnLi9icy1jYXItcmVhZGVyLmpzJ1xuaW1wb3J0IHBpcGUgZnJvbSAnaXQtcGlwZSdcblxuY29uc3QgTUFYX1NUT1JFX1JFVFJJRVMgPSA1XG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9VUExPQURTID0gM1xuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDUwIC8vIGNodW5rIHRvIH41ME1CIENBUnNcbmNvbnN0IFJBVEVfTElNSVRfUkVRVUVTVFMgPSAzMFxuY29uc3QgUkFURV9MSU1JVF9QRVJJT0QgPSAxMCAqIDEwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5TZXJ2aWNlfSBTZXJ2aWNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DSURTdHJpbmd9IENJRFN0cmluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRGVhbH0gRGVhbFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRmlsZU9iamVjdH0gRmlsZU9iamVjdFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRmlsZXNTb3VyY2V9IEZpbGVzU291cmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5QaW59IFBpblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2FyUmVhZGVyfSBDYXJSZWFkZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBCbG9ja3N0b3JlSVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUmF0ZUxpbWl0ZXJ9IFJhdGVMaW1pdGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5SZXF1ZXN0T3B0aW9uc30gUmVxdWVzdE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEByZXR1cm5zIHtSYXRlTGltaXRlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhdGVMaW1pdGVyKCkge1xuICBjb25zdCB0aHJvdHRsZSA9IHRocm90dGxlZFF1ZXVlKFJBVEVfTElNSVRfUkVRVUVTVFMsIFJBVEVfTElNSVRfUEVSSU9EKVxuICByZXR1cm4gKCkgPT4gdGhyb3R0bGUoKCkgPT4ge30pXG59XG5cbi8qKlxuICogUmF0ZSBsaW1pdGVyIHVzZWQgYnkgc3RhdGljIEFQSSBpZiBubyByYXRlIGxpbWl0ZXIgaXMgcGFzc2VkLiBOb3RlIHRoYXQgZWFjaFxuICogaW5zdGFuY2Ugb2YgdGhlIE5GVFN0b3JhZ2UgY2xhc3MgZ2V0cyBpdCdzIG93biBsaW1pdGVyIGlmIG5vbmUgaXMgcGFzc2VkLlxuICogVGhpcyBpcyBiZWNhdXNlIHJhdGUgbGltaXRzIGFyZSBlbmZvcmNlZCBwZXIgQVBJIHRva2VuLlxuICovXG5jb25zdCBnbG9iYWxSYXRlTGltaXRlciA9IGNyZWF0ZVJhdGVMaW1pdGVyKClcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW48VD59IFRva2VuVHlwZVxuICovXG5cbi8qKlxuICogQGltcGxlbWVudHMge1NlcnZpY2V9XG4gKi9cbmNsYXNzIE5GVFN0b3JhZ2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNsaWVudCBib3VuZCB0byB0aGUgZ2l2ZW4gYG9wdGlvbnMudG9rZW5gIGFuZFxuICAgKiBgb3B0aW9ucy5lbmRwb2ludGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IE5GVFN0b3JhZ2UsIEZpbGUsIEJsb2IgfSBmcm9tIFwibmZ0LnN0b3JhZ2VcIlxuICAgKiBjb25zdCBjbGllbnQgPSBuZXcgTkZUU3RvcmFnZSh7IHRva2VuOiBBUElfVE9LRU4gfSlcbiAgICpcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlQmxvYihuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pKVxuICAgKiBgYGBcbiAgICogT3B0aW9uYWxseSB5b3UgY291bGQgcGFzcyBhbiBhbHRlcm5hdGl2ZSBBUEkgZW5kcG9pbnQgKGUuZy4gZm9yIHRlc3RpbmcpXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IE5GVFN0b3JhZ2UgfSBmcm9tIFwibmZ0LnN0b3JhZ2VcIlxuICAgKiBjb25zdCBjbGllbnQgPSBuZXcgTkZUU3RvcmFnZSh7XG4gICAqICAgdG9rZW46IEFQSV9UT0tFTlxuICAgKiAgIGVuZHBvaW50OiBuZXcgVVJMKCdodHRwOi8vbG9jYWxob3N0OjgwODAvJylcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7e3Rva2VuOiBzdHJpbmcsIGVuZHBvaW50PzogVVJMLCByYXRlTGltaXRlcj86IFJhdGVMaW1pdGVyLCBkaWQ/OiBzdHJpbmd9fSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9rZW4sXG4gICAgZGlkLFxuICAgIGVuZHBvaW50ID0gbmV3IFVSTCgnaHR0cHM6Ly9hcGkubmZ0LnN0b3JhZ2UnKSxcbiAgICByYXRlTGltaXRlcixcbiAgfSkge1xuICAgIC8qKlxuICAgICAqIEF1dGhvcml6YXRpb24gdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnRva2VuID0gdG9rZW5cbiAgICAvKipcbiAgICAgKiBTZXJ2aWNlIEFQSSBlbmRwb2ludCBgVVJMYC5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnRcbiAgICAvKipcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnJhdGVMaW1pdGVyID0gcmF0ZUxpbWl0ZXIgfHwgY3JlYXRlUmF0ZUxpbWl0ZXIoKVxuXG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5kaWQgPSBkaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAaGlkZGVuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kaWRdXG4gICAqL1xuICBzdGF0aWMgYXV0aCh7IHRva2VuLCBkaWQgfSkge1xuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0b2tlbicpXG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgJ1gtQ2xpZW50JzogJ25mdC5zdG9yYWdlL2pzJyxcbiAgICAgIC4uLihkaWQgPyB7ICd4LWFnZW50LWRpZCc6IGRpZCB9IDoge30pLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBzaW5nbGUgZmlsZSBhbmQgcmV0dXJucyBpdHMgQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlQmxvYihzZXJ2aWNlLCBibG9iLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmxvY2tzdG9yZSA9IG5ldyBCbG9ja3N0b3JlKClcbiAgICBsZXQgY2lkU3RyaW5nXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBjaWQsIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVCbG9iKGJsb2IsIHsgYmxvY2tzdG9yZSB9KVxuICAgICAgYXdhaXQgTkZUU3RvcmFnZS5zdG9yZUNhcihzZXJ2aWNlLCBjYXIsIG9wdGlvbnMpXG4gICAgICBjaWRTdHJpbmcgPSBjaWQudG9TdHJpbmcoKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKClcbiAgICB9XG5cbiAgICByZXR1cm4gY2lkU3RyaW5nXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgQ0FSIGZpbGUgYW5kIHJldHVybnMgaXRzIHJvb3QgQ0lELlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtCbG9ifENhclJlYWRlcn0gY2FyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DYXJTdG9yZXJPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8Q0lEU3RyaW5nPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZUNhcihcbiAgICB7IGVuZHBvaW50LCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCAuLi50b2tlbiB9LFxuICAgIGNhcixcbiAgICB7IG9uU3RvcmVkQ2h1bmssIG1heFJldHJpZXMsIG1heENodW5rU2l6ZSwgZGVjb2RlcnMsIHNpZ25hbCB9ID0ge31cbiAgKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCgndXBsb2FkLycsIGVuZHBvaW50KVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAuLi5ORlRTdG9yYWdlLmF1dGgodG9rZW4pLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYXInLFxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTaXplID0gbWF4Q2h1bmtTaXplIHx8IE1BWF9DSFVOS19TSVpFXG4gICAgY29uc3Qgc3BsaXR0ZXIgPVxuICAgICAgY2FyIGluc3RhbmNlb2YgQmxvYlxuICAgICAgICA/IGF3YWl0IFRyZWV3YWxrQ2FyU3BsaXR0ZXIuZnJvbUJsb2IoY2FyLCB0YXJnZXRTaXplLCB7IGRlY29kZXJzIH0pXG4gICAgICAgIDogbmV3IFRyZWV3YWxrQ2FyU3BsaXR0ZXIoY2FyLCB0YXJnZXRTaXplLCB7IGRlY29kZXJzIH0pXG5cbiAgICBjb25zdCB1cGxvYWQgPSB0cmFuc2Zvcm0oXG4gICAgICBNQVhfQ09OQ1VSUkVOVF9VUExPQURTLFxuICAgICAgYXN5bmMgZnVuY3Rpb24gKC8qKiBAdHlwZSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gKi8gY2FyKSB7XG4gICAgICAgIGNvbnN0IGNhclBhcnRzID0gW11cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIGNhcikge1xuICAgICAgICAgIGNhclBhcnRzLnB1c2gocGFydClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXJGaWxlID0gbmV3IEJsb2IoY2FyUGFydHMsIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2NhcicgfSlcbiAgICAgICAgLyoqIEB0eXBlIHtCbG9ifEFycmF5QnVmZmVyfSAqL1xuICAgICAgICBsZXQgYm9keSA9IGNhckZpbGVcbiAgICAgICAgLy8gRklYTUU6IHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvIGF3YWl0IGFycmF5QnVmZmVyKCkhXG4gICAgICAgIC8vIE5vZGUuanMgMjAgaGFuZ3MgcmVhZGluZyB0aGUgc3RyZWFtIChpdCBuZXZlciBlbmRzKSBidXQgaW5cbiAgICAgICAgLy8gb2xkZXIgbm9kZSB2ZXJzaW9ucyBhbmQgdGhlIGJyb3dzZXIgaXQgaXMgZmluZSB0byBwYXNzIGEgYmxvYi5cbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgICAgICBpZiAocGFyc2VJbnQoZ2xvYmFsVGhpcy5wcm9jZXNzPy52ZXJzaW9ucz8ubm9kZSkgPiAxOCkge1xuICAgICAgICAgIGJvZHkgPSBhd2FpdCBib2R5LmFycmF5QnVmZmVyKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWQgPSBhd2FpdCBwUmV0cnkoXG4gICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtSZXNwb25zZX0gKi9cbiAgICAgICAgICAgIGxldCByZXNwb25zZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGNhdGNoICgvKiogQHR5cGUge2FueX0gKi8gZXJyKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBtZSBhbmQgdGVzdCB3aGVuIGNsaWVudCBhY2NlcHRzIGN1c3RvbSBmZXRjaCBpbXBsXG4gICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgICAgICAgICAgICAgdGhyb3cgc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkID8gbmV3IEFib3J0RXJyb3IoZXJyKSA6IGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgICAgICAgLy8gZG8gbm90IHJldHJ5IGlmIHVuYXV0aG9yaXplZCAtIHdpbGwgbm90IHN1Y2NlZWRcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZS5jaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHJpZXM6IG1heFJldHJpZXMgPT0gbnVsbCA/IE1BWF9TVE9SRV9SRVRSSUVTIDogbWF4UmV0cmllcyxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgb25TdG9yZWRDaHVuayAmJiBvblN0b3JlZENodW5rKGNhckZpbGUuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGNpZFxuICAgICAgfVxuICAgIClcblxuICAgIGxldCByb290XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaWQgb2YgdXBsb2FkKHNwbGl0dGVyLmNhcnMoKSkpIHtcbiAgICAgIHJvb3QgPSBjaWRcbiAgICB9XG5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtDSURTdHJpbmd9ICovIChyb290KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIGRpcmVjdG9yeSBvZiBmaWxlcyBhbmQgcmV0dXJucyBhIENJRC4gUHJvdmlkZWQgZmlsZXMgKipNVVNUKipcbiAgICogYmUgd2l0aGluIHRoZSBzYW1lIGRpcmVjdG9yeSwgb3RoZXJ3aXNlIGVycm9yIGlzIHJhaXNlZCBlLmcuIGBmb28vYmFyLnBuZ2AsXG4gICAqIGBmb28vYmxhL2Jhei5qc29uYCBpcyBvayBidXQgYGZvby9iYXIucG5nYCwgYGJsYS9iYXouanNvbmAgaXMgbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtGaWxlc1NvdXJjZX0gZmlsZXNTb3VyY2VcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmVEaXJlY3Rvcnkoc2VydmljZSwgZmlsZXNTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGxldCBjaWRTdHJpbmdcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBjaWQsIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVEaXJlY3RvcnkoZmlsZXNTb3VyY2UsIHtcbiAgICAgICAgYmxvY2tzdG9yZSxcbiAgICAgIH0pXG4gICAgICBhd2FpdCBORlRTdG9yYWdlLnN0b3JlQ2FyKHNlcnZpY2UsIGNhciwgb3B0aW9ucylcbiAgICAgIGNpZFN0cmluZyA9IGNpZC50b1N0cmluZygpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGJsb2Nrc3RvcmUuY2xvc2UoKVxuICAgIH1cblxuICAgIHJldHVybiBjaWRTdHJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIGdpdmVuIHRva2VuIGFuZCBhbGwgcmVzb3VyY2VzIGl0IHJlZmVyZW5jZXMgKGluIHRoZSBmb3JtIG9mIGFcbiAgICogRmlsZSBvciBhIEJsb2IpIGFsb25nIHdpdGggYSBtZXRhZGF0YSBKU09OIGFzIHNwZWNpZmljZWQgaW4gRVJDLTExNTUuIFRoZVxuICAgKiBgdG9rZW4uaW1hZ2VgIG11c3QgYmUgZWl0aGVyIGEgYEZpbGVgIG9yIGEgYEJsb2JgIGluc3RhbmNlLCB3aGljaCB3aWxsIGJlXG4gICAqIHN0b3JlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudCBhZGRyZXNzIFVSTCB3aWxsIGJlIHNhdmVkIGluIHRoZVxuICAgKiBtZXRhZGF0YSBKU09OIGZpbGUgdW5kZXIgYGltYWdlYCBmaWVsZC5cbiAgICpcbiAgICogSWYgYHRva2VuLnByb3BlcnRpZXNgIGNvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBgRmlsZWAgb3IgYEJsb2JgIHZhbHVlcyxcbiAgICogdGhvc2UgYWxzbyBnZXQgc3RvcmVkIGFuZCB0aGVpciBVUkxzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT05cbiAgICogZmlsZSBpbiB0aGVpciBwbGFjZS5cbiAgICpcbiAgICogTm90ZTogVVJMcyBmb3IgYEZpbGVgIG9iamVjdHMgd2lsbCByZXRhaW4gZmlsZSBuYW1lcyBlLmcuIGluIGNhc2Ugb2ZcbiAgICogYG5ldyBGaWxlKFtieXRlc10sICdjYXQucG5nJywgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KWAgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuICAgKiBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZSBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2NhdC5wbmdgLiBGb3IgYEJsb2JgXG4gICAqIG9iamVjdHMsIHRoZSBVUkwgd2lsbCBub3QgaGF2ZSBhIGZpbGUgbmFtZSBuYW1lIG9yIG1pbWUgdHlwZSwgaW5zdGVhZCBpdFxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlXG4gICAqIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvYmxvYmAuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge1R9IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlblR5cGU8VD4+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlKHNlcnZpY2UsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZU5GVChtZXRhZGF0YSlcbiAgICBhd2FpdCBORlRTdG9yYWdlLnN0b3JlQ2FyKHNlcnZpY2UsIGNhciwgb3B0aW9ucylcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBzdG9yZWQgTkZUIGJ5IGl0cyBDSUQuIE5vdGUgdGhlIE5GVCBtdXN0XG4gICAqIGhhdmUgcHJldmlvdXNseSBiZWVuIHN0b3JlZCBieSB0aGlzIGFjY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlN0YXR1c1Jlc3VsdD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RhdHVzKFxuICAgIHsgZW5kcG9pbnQsIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIC4uLnRva2VuIH0sXG4gICAgY2lkLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtjaWR9L2AsIGVuZHBvaW50KVxuICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczogTkZUU3RvcmFnZS5hdXRoKHRva2VuKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmF0ZSBsaW1pdGVkJylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBpZiAocmVzdWx0Lm9rKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaWQ6IHJlc3VsdC52YWx1ZS5jaWQsXG4gICAgICAgIGRlYWxzOiBkZWNvZGVEZWFscyhyZXN1bHQudmFsdWUuZGVhbHMpLFxuICAgICAgICBzaXplOiByZXN1bHQudmFsdWUuc2l6ZSxcbiAgICAgICAgcGluOiBkZWNvZGVQaW4ocmVzdWx0LnZhbHVlLnBpbiksXG4gICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKHJlc3VsdC52YWx1ZS5jcmVhdGVkKSxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIENJRCBvZiBhbiBORlQgaXMgYmVpbmcgc3RvcmVkIGJ5IE5GVC5TdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUHVibGljU2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNoZWNrUmVzdWx0Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBjaGVjayhcbiAgICB7IGVuZHBvaW50LCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyIH0sXG4gICAgY2lkLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgY2hlY2svJHtjaWR9L2AsIGVuZHBvaW50KVxuICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICBzaWduYWw6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwsXG4gICAgfSlcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgaWYgKHJlc3VsdC5vaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lkOiByZXN1bHQudmFsdWUuY2lkLFxuICAgICAgICBkZWFsczogZGVjb2RlRGVhbHMocmVzdWx0LnZhbHVlLmRlYWxzKSxcbiAgICAgICAgcGluOiByZXN1bHQudmFsdWUucGluLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RvcmVkIGNvbnRlbnQgYnkgaXRzIENJRCBmcm9tIHRoaXMgYWNjb3VudC4gUGxlYXNlIG5vdGUgdGhhdFxuICAgKiBldmVuIGlmIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzZXJ2aWNlIG90aGVyIG5vZGVzIHRoYXQgaGF2ZVxuICAgKiByZXBsaWNhdGVkIGl0IG1pZ2h0IHN0aWxsIGNvbnRpbnVlIHByb3ZpZGluZyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShcbiAgICB7IGVuZHBvaW50LCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCAuLi50b2tlbiB9LFxuICAgIGNpZCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y2lkfS9gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IE5GVFN0b3JhZ2UuYXV0aCh0b2tlbiksXG4gICAgICBzaWduYWw6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwsXG4gICAgfSlcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgdGhlIGdpdmVuIHRva2VuIGFuZCBhbGwgcmVzb3VyY2VzIGl0IHJlZmVyZW5jZXMgKGluIHRoZSBmb3JtIG9mIGFcbiAgICogRmlsZSBvciBhIEJsb2IpIGFsb25nIHdpdGggYSBtZXRhZGF0YSBKU09OIGFzIHNwZWNpZmljZWQgaW4gRVJDLTExNTUgdG8gYVxuICAgKiBDQVIgZmlsZS4gVGhlIGB0b2tlbi5pbWFnZWAgbXVzdCBiZSBlaXRoZXIgYSBgRmlsZWAgb3IgYSBgQmxvYmAgaW5zdGFuY2UsXG4gICAqIHdoaWNoIHdpbGwgYmUgc3RvcmVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb250ZW50IGFkZHJlc3MgVVJMIHdpbGwgYmVcbiAgICogc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT04gZmlsZSB1bmRlciBgaW1hZ2VgIGZpZWxkLlxuICAgKlxuICAgKiBJZiBgdG9rZW4ucHJvcGVydGllc2AgY29udGFpbnMgcHJvcGVydGllcyB3aXRoIGBGaWxlYCBvciBgQmxvYmAgdmFsdWVzLFxuICAgKiB0aG9zZSBhbHNvIGdldCBzdG9yZWQgYW5kIHRoZWlyIFVSTHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTlxuICAgKiBmaWxlIGluIHRoZWlyIHBsYWNlLlxuICAgKlxuICAgKiBOb3RlOiBVUkxzIGZvciBgRmlsZWAgb2JqZWN0cyB3aWxsIHJldGFpbiBmaWxlIG5hbWVzIGUuZy4gaW4gY2FzZSBvZlxuICAgKiBgbmV3IEZpbGUoW2J5dGVzXSwgJ2NhdC5wbmcnLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pYCB3aWxsIGJlIHRyYW5zZm9ybWVkXG4gICAqIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvY2F0LnBuZ2AuIEZvciBgQmxvYmBcbiAgICogb2JqZWN0cywgdGhlIFVSTCB3aWxsIG5vdCBoYXZlIGEgZmlsZSBuYW1lIG5hbWUgb3IgbWltZSB0eXBlLCBpbnN0ZWFkIGl0XG4gICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2VcbiAgICogYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9ibG9iYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBORlRTdG9yYWdlLmVuY29kZU5GVCh7XG4gICAqICAgbmFtZTogJ25mdC5zdG9yYWdlIHN0b3JlIHRlc3QnLFxuICAgKiAgIGRlc2NyaXB0aW9uOiAnVGVzdCBFUkMtMTE1NSBjb21wYXRpYmxlIG1ldGFkYXRhLicsXG4gICAqICAgaW1hZ2U6IG5ldyBGaWxlKFsnPERBVEE+J10sICdwaW5waWUuanBnJywgeyB0eXBlOiAnaW1hZ2UvanBnJyB9KSxcbiAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAqICAgICBjdXN0b206ICdDdXN0b20gZGF0YSBjYW4gYXBwZWFyIGhlcmUsIGZpbGVzIGFyZSBhdXRvIHVwbG9hZGVkLicsXG4gICAqICAgICBmaWxlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAnUkVBRE1FLm1kJywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSksXG4gICAqICAgfVxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zb2xlLmxvZygnSVBGUyBVUkwgZm9yIHRoZSBtZXRhZGF0YTonLCB0b2tlbi51cmwpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIGNvbnRlbnRzOlxcbicsIHRva2VuLmRhdGEpXG4gICAqIGNvbnNvbGUubG9nKCdtZXRhZGF0YS5qc29uIHdpdGggSVBGUyBnYXRld2F5IFVSTHM6XFxuJywgdG9rZW4uZW1iZWQoKSlcbiAgICpcbiAgICogLy8gTm93IHN0b3JlIHRoZSBDQVIgZmlsZSBvbiBORlQuU3RvcmFnZVxuICAgKiBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAgICogQHBhcmFtIHtUfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogQ0lELCB0b2tlbjogVG9rZW5UeXBlPFQ+LCBjYXI6IENhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGVORlQoaW5wdXQpIHtcbiAgICB2YWxpZGF0ZUVSQzExNTUoaW5wdXQpXG4gICAgcmV0dXJuIFRva2VuLlRva2VuLmVuY29kZShpbnB1dClcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgc2luZ2xlIGZpbGUgdG8gYSBDQVIgZmlsZSBhbmQgYWxzbyByZXR1cm5zIGl0cyByb290IENJRC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY29udGVudCA9IG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSlcbiAgICogY29uc3QgeyBjaWQsIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVCbG9iKGNvbnRlbnQpXG4gICAqXG4gICAqIC8vIFJvb3QgQ0lEIG9mIHRoZSBmaWxlXG4gICAqIGNvbnNvbGUubG9nKGNpZC50b1N0cmluZygpKVxuICAgKlxuICAgKiAvLyBOb3cgc3RvcmUgdGhlIENBUiBmaWxlIG9uIE5GVC5TdG9yYWdlXG4gICAqIGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jsb2Nrc3RvcmVJfSBbb3B0aW9ucy5ibG9ja3N0b3JlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogQ0lELCBjYXI6IENhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGVCbG9iKGJsb2IsIHsgYmxvY2tzdG9yZSB9ID0ge30pIHtcbiAgICBpZiAoYmxvYi5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnQgc2l6ZSBpcyAwLCBtYWtlIHN1cmUgdG8gcHJvdmlkZSBzb21lIGNvbnRlbnQnKVxuICAgIH1cbiAgICByZXR1cm4gcGFja0NhcihbdG9JbXBvcnRDYW5kaWRhdGUoJ2Jsb2InLCBibG9iKV0sIHtcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgZGlyZWN0b3J5IG9mIGZpbGVzIHRvIGEgQ0FSIGZpbGUgYW5kIGFsc28gcmV0dXJucyB0aGUgcm9vdCBDSUQuXG4gICAqIFByb3ZpZGVkIGZpbGVzICoqTVVTVCoqIGJlIHdpdGhpbiB0aGUgc2FtZSBkaXJlY3RvcnksIG90aGVyd2lzZSBlcnJvciBpc1xuICAgKiByYWlzZWQgZS5nLiBgZm9vL2Jhci5wbmdgLCBgZm9vL2JsYS9iYXouanNvbmAgaXMgb2sgYnV0IGBmb28vYmFyLnBuZ2AsXG4gICAqIGBibGEvYmF6Lmpzb25gIGlzIG5vdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgeyBjaWQsIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVEaXJlY3RvcnkoW1xuICAgKiAgIG5ldyBGaWxlKFsnaGVsbG8gd29ybGQnXSwgJ2hlbGxvLnR4dCcpLFxuICAgKiAgIG5ldyBGaWxlKFtKU09OLnN0cmluZ2lmeSh7J2Zyb20nOiAnaW5jb2duaXRvJ30sIG51bGwsIDIpXSwgJ21ldGFkYXRhLmpzb24nKVxuICAgKiBdKVxuICAgKlxuICAgKiAvLyBSb290IENJRCBvZiB0aGUgZGlyZWN0b3J5XG4gICAqIGNvbnNvbGUubG9nKGNpZC50b1N0cmluZygpKVxuICAgKlxuICAgKiAvLyBOb3cgc3RvcmUgdGhlIENBUiBmaWxlIG9uIE5GVC5TdG9yYWdlXG4gICAqIGF3YWl0IGNsaWVudC5zdG9yZUNhcihjYXIpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVzU291cmNlfSBmaWxlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7QmxvY2tzdG9yZUl9IFtvcHRpb25zLmJsb2Nrc3RvcmVdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIGNhcjogQ2FyUmVhZGVyIH0+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY29kZURpcmVjdG9yeShmaWxlcywgeyBibG9ja3N0b3JlIH0gPSB7fSkge1xuICAgIGxldCBzaXplID0gMFxuICAgIGNvbnN0IGlucHV0ID0gcGlwZShmaWxlcywgYXN5bmMgZnVuY3Rpb24qIChmaWxlcykge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIHlpZWxkIHRvSW1wb3J0Q2FuZGlkYXRlKGZpbGUubmFtZSwgZmlsZSlcbiAgICAgICAgc2l6ZSArPSBmaWxlLnNpemVcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IHBhY2tlZCA9IGF3YWl0IHBhY2tDYXIoaW5wdXQsIHtcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogdHJ1ZSxcbiAgICB9KVxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUb3RhbCBzaXplIG9mIGZpbGVzIHNob3VsZCBleGNlZWQgMCwgbWFrZSBzdXJlIHRvIHByb3ZpZGUgc29tZSBjb250ZW50J1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcGFja2VkXG4gIH1cblxuICAvLyBKdXN0IGEgc3VnYXIgc28geW91IGRvbid0IGhhdmUgdG8gcGFzcyBhcm91bmQgZW5kcG9pbnQgYW5kIHRva2VuIGFyb3VuZC5cblxuICAvKipcbiAgICogU3RvcmVzIGEgc2luZ2xlIGZpbGUgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgQ29udGVudCBJZGVudGlmaWVyIChDSUQpLlxuICAgKiBUYWtlcyBhIFtCbG9iXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYi9CbG9iKVxuICAgKiBvciBhIFtGaWxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuIE5vdGVcbiAgICogdGhhdCBubyBmaWxlIG5hbWUgb3IgZmlsZSBtZXRhZGF0YSBpcyByZXRhaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY29udGVudCA9IG5ldyBCbG9iKFsnaGVsbG8gd29ybGQnXSlcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlQmxvYihjb250ZW50KVxuICAgKiBjaWQgLy8+ICd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5J1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmVCbG9iKGJsb2IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZUJsb2IodGhpcywgYmxvYiwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgZmlsZXMgZW5jb2RlZCBhcyBhIHNpbmdsZSBbQ29udGVudCBBZGRyZXNzZWQgQXJjaGl2ZVxuICAgKiAoQ0FSKV0oaHR0cHM6Ly9naXRodWIuY29tL2lwbGQvc3BlY3MvYmxvYi9tYXN0ZXIvYmxvY2stbGF5ZXIvY29udGVudC1hZGRyZXNzYWJsZS1hcmNoaXZlcy5tZCkuXG4gICAqXG4gICAqIFRha2VzIGEgW0Jsb2JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iL0Jsb2IpXG4gICAqIG9yIGEgW0ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBDb250ZW50IElkZW50aWZpZXIgKENJRCkuXG4gICAqXG4gICAqIFNlZSB0aGUgW2BpcGZzLWNhcmAgZG9jc10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaXBmcy1jYXIpIGZvciBtb3JlXG4gICAqIGRldGFpbHMgb24gcGFja2luZyBhIENBUiBmaWxlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBwYWNrIH0gZnJvbSAnaXBmcy1jYXIvcGFjaydcbiAgICogaW1wb3J0IHsgQ2FyUmVhZGVyIH0gZnJvbSAnQGlwbGQvY2FyJ1xuICAgKiBjb25zdCB7IG91dCwgcm9vdCB9ID0gYXdhaXQgcGFjayh7XG4gICAqICBpbnB1dDogZnMuY3JlYXRlUmVhZFN0cmVhbSgncGlucGllLnBkZicpXG4gICAqIH0pXG4gICAqIGNvbnN0IGV4cGVjdGVkQ2lkID0gcm9vdC50b1N0cmluZygpXG4gICAqIGNvbnN0IGNhclJlYWRlciA9IGF3YWl0IENhclJlYWRlci5mcm9tSXRlcmFibGUob3V0KVxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBzdG9yYWdlLnN0b3JlQ2FyKGNhclJlYWRlcilcbiAgICogY29uc29sZS5hc3NlcnQoY2lkID09PSBleHBlY3RlZENpZClcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBpbXBvcnQgeyBwYWNrVG9CbG9iIH0gZnJvbSAnaXBmcy1jYXIvcGFjay9ibG9iJ1xuICAgKiBjb25zdCBkYXRhID0gJ0hlbGxvIHdvcmxkJ1xuICAgKiBjb25zdCB7IHJvb3QsIGNhciB9ID0gYXdhaXQgcGFja1RvQmxvYih7IGlucHV0OiBbbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpXSB9KVxuICAgKiBjb25zdCBleHBlY3RlZENpZCA9IHJvb3QudG9TdHJpbmcoKVxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBjb25zb2xlLmFzc2VydChjaWQgPT09IGV4cGVjdGVkQ2lkKVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtCbG9ifENhclJlYWRlcn0gY2FyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DYXJTdG9yZXJPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlQ2FyKGNhciwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlQ2FyKHRoaXMsIGNhciwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBkaXJlY3Rvcnkgb2YgZmlsZXMgYW5kIHJldHVybnMgYSBDSUQgZm9yIHRoZSBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZURpcmVjdG9yeShbXG4gICAqICAgbmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnaGVsbG8udHh0JyksXG4gICAqICAgbmV3IEZpbGUoW0pTT04uc3RyaW5naWZ5KHsnZnJvbSc6ICdpbmNvZ25pdG8nfSwgbnVsbCwgMildLCAnbWV0YWRhdGEuanNvbicpXG4gICAqIF0pXG4gICAqIGNpZCAvLz5cbiAgICogYGBgXG4gICAqXG4gICAqIEFyZ3VtZW50IGNhbiBiZSBhIFtGaWxlTGlzdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGVMaXN0KVxuICAgKiBpbnN0YW5jZSBhcyB3ZWxsLCBpbiB3aGljaCBjYXNlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgd2lsbCBiZSByZXRhaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtGaWxlc1NvdXJjZX0gZmlsZXNcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZURpcmVjdG9yeShmaWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0b3JlRGlyZWN0b3J5KHRoaXMsIGZpbGVzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0dXMgb2YgdGhlIHN0b3JlZCBORlQgYnkgaXRzIENJRC4gTm90ZSB0aGUgTkZUIG11c3RcbiAgICogaGF2ZSBwcmV2aW91c2x5IGJlZW4gc3RvcmVkIGJ5IHRoaXMgYWNjb3VudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xpZW50LnN0YXR1cygnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RhdHVzKGNpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLnN0YXR1cyh0aGlzLCBjaWQsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzdG9yZWQgY29udGVudCBieSBpdHMgQ0lEIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqXG4gICAqID4gUGxlYXNlIG5vdGUgdGhhdCBldmVuIGlmIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzZXJ2aWNlIG90aGVyIG5vZGVzXG4gICAqIHRoYXQgaGF2ZSByZXBsaWNhdGVkIGl0IG1pZ2h0IHN0aWxsIGNvbnRpbnVlIHByb3ZpZGluZyBpdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogYXdhaXQgY2xpZW50LmRlbGV0ZSgnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgZGVsZXRlKGNpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBORlRTdG9yYWdlLmRlbGV0ZSh0aGlzLCBjaWQsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBDSUQgb2YgYW4gTkZUIGlzIGJlaW5nIHN0b3JlZCBieSBuZnQuc3RvcmFnZS4gVGhyb3dzIGlmIHRoZSBORlRcbiAgICogd2FzIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xpZW50LmNoZWNrKCd6ZGo3V245RlFBVVJDUDZNYndjV3V6aTd1NjVrQXNYQ2RqTlRraGJKY29hWEJ1c3E5JylcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBjaGVjayhjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5jaGVjayh0aGlzLCBjaWQsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiB0b2tlbiBhbmQgYWxsIHJlc291cmNlcyBpdCByZWZlcmVuY2VzIChpbiB0aGUgZm9ybSBvZiBhXG4gICAqIEZpbGUgb3IgYSBCbG9iKSBhbG9uZyB3aXRoIGEgbWV0YWRhdGEgSlNPTiBhcyBzcGVjaWZpY2VkIGluXG4gICAqIFtFUkMtMTE1NV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTU1I21ldGFkYXRhKS4gVGhlXG4gICAqIGB0b2tlbi5pbWFnZWAgbXVzdCBiZSBlaXRoZXIgYSBgRmlsZWAgb3IgYSBgQmxvYmAgaW5zdGFuY2UsIHdoaWNoIHdpbGwgYmVcbiAgICogc3RvcmVkIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb250ZW50IGFkZHJlc3MgVVJMIHdpbGwgYmUgc2F2ZWQgaW4gdGhlXG4gICAqIG1ldGFkYXRhIEpTT04gZmlsZSB1bmRlciBgaW1hZ2VgIGZpZWxkLlxuICAgKlxuICAgKiBJZiBgdG9rZW4ucHJvcGVydGllc2AgY29udGFpbnMgcHJvcGVydGllcyB3aXRoIGBGaWxlYCBvciBgQmxvYmAgdmFsdWVzLFxuICAgKiB0aG9zZSBhbHNvIGdldCBzdG9yZWQgYW5kIHRoZWlyIFVSTHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgbWV0YWRhdGEgSlNPTlxuICAgKiBmaWxlIGluIHRoZWlyIHBsYWNlLlxuICAgKlxuICAgKiBOb3RlOiBVUkxzIGZvciBgRmlsZWAgb2JqZWN0cyB3aWxsIHJldGFpbiBmaWxlIG5hbWVzIGUuZy4gaW4gY2FzZSBvZlxuICAgKiBgbmV3IEZpbGUoW2J5dGVzXSwgJ2NhdC5wbmcnLCB7IHR5cGU6ICdpbWFnZS9wbmcnIH0pYCB3aWxsIGJlIHRyYW5zZm9ybWVkXG4gICAqIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvY2F0LnBuZ2AuIEZvciBgQmxvYmBcbiAgICogb2JqZWN0cywgdGhlIFVSTCB3aWxsIG5vdCBoYXZlIGEgZmlsZSBuYW1lIG5hbWUgb3IgbWltZSB0eXBlLCBpbnN0ZWFkIGl0XG4gICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2VcbiAgICogYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9ibG9iYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjbGllbnQuc3RvcmUoe1xuICAgKiAgIG5hbWU6ICduZnQuc3RvcmFnZSBzdG9yZSB0ZXN0JyxcbiAgICogICBkZXNjcmlwdGlvbjogJ1Rlc3QgRVJDLTExNTUgY29tcGF0aWJsZSBtZXRhZGF0YS4nLFxuICAgKiAgIGltYWdlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAncGlucGllLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZycgfSksXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgY3VzdG9tOiAnQ3VzdG9tIGRhdGEgY2FuIGFwcGVhciBoZXJlLCBmaWxlcyBhcmUgYXV0byB1cGxvYWRlZC4nLFxuICAgKiAgICAgZmlsZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ1JFQURNRS5tZCcsIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pLFxuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogY29uc29sZS5sb2coJ0lQRlMgVVJMIGZvciB0aGUgbWV0YWRhdGE6JywgbWV0YWRhdGEudXJsKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiBjb250ZW50czpcXG4nLCBtZXRhZGF0YS5kYXRhKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiB3aXRoIElQRlMgZ2F0ZXdheSBVUkxzOlxcbicsIG1ldGFkYXRhLmVtYmVkKCkpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1R9IHRva2VuXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmUodG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZSh0aGlzLCB0b2tlbiwgb3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqIENhc3QgYW4gaXRlcmFibGUgdG8gYW4gYXN5bmNJdGVyYWJsZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7SXRlcmFibGU8VD59IGl0ZXJhYmxlXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICB5aWVsZCBpdGVtXG4gICAgfVxuICB9KSgpXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7VH0gbWV0YWRhdGFcbiAqL1xuY29uc3QgdmFsaWRhdGVFUkMxMTU1ID0gKHsgbmFtZSwgZGVzY3JpcHRpb24sIGltYWdlLCBkZWNpbWFscyB9KSA9PiB7XG4gIC8vIEp1c3QgdmFsaWRhdGUgdGhhdCBleHBlY3RlZCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnc3RyaW5nIHByb3BlcnR5IGBuYW1lYCBpZGVudGlmeWluZyB0aGUgYXNzZXQgaXMgcmVxdWlyZWQnXG4gICAgKVxuICB9XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdzdHJpbmcgcHJvcGVydHkgYGRlc2NyaXB0aW9uYCBkZXNjcmliaW5nIGFzc2V0IGlzIHJlcXVpcmVkJ1xuICAgIClcbiAgfVxuICBpZiAoIShpbWFnZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgYGltYWdlYCBtdXN0IGJlIGEgQmxvYiBvciBGaWxlIG9iamVjdCcpXG4gIH0gZWxzZSBpZiAoIWltYWdlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICBjb25zb2xlLndhcm4oYEFjY29yZGluZyB0byBFUkM3MjEgTWV0YWRhdGEgSlNPTiBTY2hlbWEgJ2ltYWdlJyBtdXN0IGhhdmUgJ2ltYWdlLyonIG1pbWUgdHlwZS5cblxuRm9yIGJldHRlciBpbnRlcm9wZXJhYmlsaXR5IHdlIHdvdWxkIGhpZ2hseSByZWNvbW1lbmQgc3RvcmluZyBjb250ZW50IHdpdGggZGlmZmVyZW50IG1pbWUgdHlwZSB1bmRlciAncHJvcGVydGllcycgbmFtZXNwYWNlIGUuZy4gXFxgcHJvcGVydGllczogeyB2aWRlbzogZmlsZSB9XFxgIGFuZCB1c2luZyAnaW1hZ2UnIGZpZWxkIGZvciBzdG9yaW5nIGEgcHJldmlldyBpbWFnZSBmb3IgaXQgaW5zdGVhZC5cblxuRm9yIG1vcmUgY29udGV4dCBwbGVhc2Ugc2VlIEVSQy03MjEgc3BlY2lmaWNhdGlvbiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcyMWApXG4gIH1cblxuICBpZiAodHlwZW9mIGRlY2ltYWxzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVjaW1hbHMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgYGRlY2ltYWxzYCBtdXN0IGJlIGFuIGludGVnZXIgdmFsdWUnKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJ2lwZnMtY2FyL3BhY2snKS5JbXBvcnRDYW5kaWRhdGVTdHJlYW18QXJyYXk8eyBwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IGltcG9ydCgnLi9wbGF0Zm9ybS5qcycpLlJlYWRhYmxlU3RyZWFtIH0+fSBpbnB1dFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCbG9ja3N0b3JlSX0gW29wdGlvbnMuYmxvY2tzdG9yZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud3JhcFdpdGhEaXJlY3RvcnldXG4gKi9cbmNvbnN0IHBhY2tDYXIgPSBhc3luYyAoaW5wdXQsIHsgYmxvY2tzdG9yZSwgd3JhcFdpdGhEaXJlY3RvcnkgfSA9IHt9KSA9PiB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgYmxvY2tzdG9yZSA9IGJsb2Nrc3RvcmUgfHwgbmV3IEJsb2Nrc3RvcmUoKVxuICBjb25zdCB7IHJvb3Q6IGNpZCB9ID0gYXdhaXQgcGFjayh7IGlucHV0LCBibG9ja3N0b3JlLCB3cmFwV2l0aERpcmVjdG9yeSB9KVxuICBjb25zdCBjYXIgPSBuZXcgQmxvY2tzdG9yZUNhclJlYWRlcigxLCBbY2lkXSwgYmxvY2tzdG9yZSlcbiAgcmV0dXJuIHsgY2lkLCBjYXIgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVhbFtdfSBkZWFsc1xuICogQHJldHVybnMge0RlYWxbXX1cbiAqL1xuY29uc3QgZGVjb2RlRGVhbHMgPSAoZGVhbHMpID0+XG4gIGRlYWxzLm1hcCgoZGVhbCkgPT4ge1xuICAgIGNvbnN0IHsgZGVhbEFjdGl2YXRpb24sIGRlYWxFeHBpcmF0aW9uLCBsYXN0Q2hhbmdlZCB9ID0ge1xuICAgICAgZGVhbEV4cGlyYXRpb246IG51bGwsXG4gICAgICBkZWFsQWN0aXZhdGlvbjogbnVsbCxcbiAgICAgIC4uLmRlYWwsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlYWwsXG4gICAgICBsYXN0Q2hhbmdlZDogbmV3IERhdGUobGFzdENoYW5nZWQpLFxuICAgICAgLi4uKGRlYWxBY3RpdmF0aW9uICYmIHsgZGVhbEFjdGl2YXRpb246IG5ldyBEYXRlKGRlYWxBY3RpdmF0aW9uKSB9KSxcbiAgICAgIC4uLihkZWFsRXhwaXJhdGlvbiAmJiB7IGRlYWxFeHBpcmF0aW9uOiBuZXcgRGF0ZShkZWFsRXhwaXJhdGlvbikgfSksXG4gICAgfVxuICB9KVxuXG4vKipcbiAqIEBwYXJhbSB7UGlufSBwaW5cbiAqIEByZXR1cm5zIHtQaW59XG4gKi9cbmNvbnN0IGRlY29kZVBpbiA9IChwaW4pID0+ICh7IC4uLnBpbiwgY3JlYXRlZDogbmV3IERhdGUocGluLmNyZWF0ZWQpIH0pXG5cbi8qKlxuICogQ29udmVydCB0aGUgcGFzc2VkIGJsb2IgdG8gYW4gXCJpbXBvcnQgY2FuZGlkYXRlXCIgLSBhbiBvYmplY3Qgc3VpdGFibGUgZm9yXG4gKiBwYXNzaW5nIHRvIHRoZSBpcGZzLXVuaXhmcy1pbXBvcnRlci4gTm90ZTogY29udGVudCBpcyBhbiBhY2Nlc3NvciBzbyB0aGF0XG4gKiB0aGUgc3RyZWFtIGlzIGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtQaWNrPEJsb2IsICdzdHJlYW0nPnx7IHN0cmVhbTogKCkgPT4gQXN5bmNJdGVyYWJsZTxVaW50OEFycmF5PiB9fSBibG9iXG4gKiBAcmV0dXJucyB7aW1wb3J0KCdpcGZzLWNvcmUtdHlwZXMvc3JjL3V0aWxzLmpzJykuSW1wb3J0Q2FuZGlkYXRlfVxuICovXG5mdW5jdGlvbiB0b0ltcG9ydENhbmRpZGF0ZShwYXRoLCBibG9iKSB7XG4gIC8qKiBAdHlwZSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gKi9cbiAgbGV0IHN0cmVhbVxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0gfHwgYmxvYi5zdHJlYW0oKVxuICAgICAgcmV0dXJuIHN0cmVhbVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IHsgTkZUU3RvcmFnZSwgRmlsZSwgQmxvYiwgRm9ybURhdGEsIHRvR2F0ZXdheVVSTCwgVG9rZW4gfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/platform.js":
/*!**************************************************!*\
  !*** ./node_modules/nft.storage/src/platform.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.Blob),\n/* harmony export */   Blockstore: () => (/* reexport safe */ ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__.FsBlockStore),\n/* harmony export */   File: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_2__.File),\n/* harmony export */   FormData: () => (/* reexport safe */ _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__.FormData),\n/* harmony export */   Headers: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Headers),\n/* harmony export */   ReadableStream: () => (/* reexport safe */ _web_std_blob__WEBPACK_IMPORTED_MODULE_1__.ReadableStream),\n/* harmony export */   Request: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Request),\n/* harmony export */   Response: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__.Response),\n/* harmony export */   fetch: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _web_std_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @web-std/fetch */ \"(ssr)/./node_modules/@web-std/fetch/src/lib.node.js\");\n/* harmony import */ var _web_std_form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web-std/form-data */ \"(ssr)/./node_modules/@web-std/form-data/src/lib.node.js\");\n/* harmony import */ var _web_std_blob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @web-std/blob */ \"(ssr)/./node_modules/@web-std/blob/src/lib.node.js\");\n/* harmony import */ var _web_std_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web-std/file */ \"(ssr)/./node_modules/@web-std/file/src/lib.node.js\");\n/* harmony import */ var ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ipfs-car/blockstore/fs */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/blockstore/fs.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3BsYXRmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtFO0FBQ3JCO0FBQ0M7QUFDSjtBQUN5Qjs7QUFZbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kLW1hbmRhdGVzLy4vbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9wbGF0Zm9ybS5qcz9hMTBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmZXRjaCwgeyBSZXF1ZXN0LCBSZXNwb25zZSwgSGVhZGVycyB9IGZyb20gJ0B3ZWItc3RkL2ZldGNoJ1xuaW1wb3J0IHsgRm9ybURhdGEgfSBmcm9tICdAd2ViLXN0ZC9mb3JtLWRhdGEnXG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJ0B3ZWItc3RkL2Jsb2InXG5pbXBvcnQgeyBGaWxlLCBCbG9iIH0gZnJvbSAnQHdlYi1zdGQvZmlsZSdcbmltcG9ydCB7IEZzQmxvY2tTdG9yZSBhcyBCbG9ja3N0b3JlIH0gZnJvbSAnaXBmcy1jYXIvYmxvY2tzdG9yZS9mcydcblxuZXhwb3J0IHtcbiAgZmV0Y2gsXG4gIFJlcXVlc3QsXG4gIFJlc3BvbnNlLFxuICBIZWFkZXJzLFxuICBCbG9iLFxuICBGb3JtRGF0YSxcbiAgRmlsZSxcbiAgUmVhZGFibGVTdHJlYW0sXG4gIEJsb2Nrc3RvcmUsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/platform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nft.storage/src/token.js":
/*!***********************************************!*\
  !*** ./node_modules/nft.storage/src/token.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   mapWith: () => (/* binding */ mapWith)\n/* harmony export */ });\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ipfs-car/pack */ \"(ssr)/./node_modules/nft.storage/node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ \"(ssr)/./node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var multiformats_block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/block */ \"(ssr)/./node_modules/multiformats/esm/src/block.js\");\n/* harmony import */ var multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/hashes/sha2 */ \"(ssr)/./node_modules/multiformats/esm/src/hashes/sha2.js\");\n/* harmony import */ var _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ipld/dag-cbor */ \"(ssr)/./node_modules/nft.storage/node_modules/@ipld/dag-cbor/esm/index.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform.js */ \"(ssr)/./node_modules/nft.storage/src/platform.js\");\n/* harmony import */ var _gateway_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gateway.js */ \"(ssr)/./node_modules/nft.storage/src/gateway.js\");\n/* harmony import */ var _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bs-car-reader.js */ \"(ssr)/./node_modules/nft.storage/src/bs-car-reader.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nclass Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: _gateway_js__WEBPACK_IMPORTED_MODULE_6__.GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      let content\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer())\n      } else {\n        content = blob.stream()\n      }\n      const { root: cid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_0__.pack)({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await multiformats_block__WEBPACK_IMPORTED_MODULE_2__.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: _ipld_dag_cbor__WEBPACK_IMPORTED_MODULE_4__,\n      hasher: multiformats_hashes_sha2__WEBPACK_IMPORTED_MODULE_3__.sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new _bs_car_reader_js__WEBPACK_IMPORTED_MODULE_7__.BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nconst embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nconst decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, (0,_gateway_js__WEBPACK_IMPORTED_MODULE_6__.toGatewayURL)(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nconst encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new _platform_js__WEBPACK_IMPORTED_MODULE_5__.FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof _platform_js__WEBPACK_IMPORTED_MODULE_5__.Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nconst mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNLO0FBQ007QUFDUjtBQUNpQjtBQUNOO0FBQ0k7O0FBRXhEO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSx5Q0FBeUM7QUFDdEQsYUFBYSwwQ0FBMEM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsd0RBQXdEO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlEQUF5RDtBQUN0RTs7QUFFQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLHdEQUF3RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxvQ0FBb0M7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixjQUFjLCtEQUErRDtBQUM3RSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUIsTUFBTTtBQUN2Qix5QkFBeUIsU0FBUyxnREFBTyxFQUFFO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixhQUFhLEdBQUc7QUFDaEIsZUFBZSxVQUFVLDRFQUE0RTtBQUNyRztBQUNBO0FBQ0EsMkJBQTJCLG9EQUFVO0FBQ3JDO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsNERBQTREO0FBQ3ZFLFdBQVcsMkRBQTJEO0FBQ3RFLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1EQUFtRDtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZC1tYW5kYXRlcy8uL25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvdG9rZW4uanM/YzY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYWNrIH0gZnJvbSAnaXBmcy1jYXIvcGFjaydcbmltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnXG5pbXBvcnQgKiBhcyBCbG9jayBmcm9tICdtdWx0aWZvcm1hdHMvYmxvY2snXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL3NoYTInXG5pbXBvcnQgKiBhcyBkYWdDYm9yIGZyb20gJ0BpcGxkL2RhZy1jYm9yJ1xuaW1wb3J0IHsgQmxvYiwgRm9ybURhdGEsIEJsb2Nrc3RvcmUgfSBmcm9tICcuL3BsYXRmb3JtLmpzJ1xuaW1wb3J0IHsgdG9HYXRld2F5VVJMLCBHQVRFV0FZIH0gZnJvbSAnLi9nYXRld2F5LmpzJ1xuaW1wb3J0IHsgQmxvY2tzdG9yZUNhclJlYWRlciB9IGZyb20gJy4vYnMtY2FyLXJlYWRlci5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2dhdGV3YXkuanMnKS5HYXRld2F5VVJMT3B0aW9uc30gRW1iZWRPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUb2tlbklucHV0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNhci9ibG9ja3N0b3JlJykuQmxvY2tzdG9yZX0gQmxvY2tzdG9yZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59IEVuY29kZWRCbG9iVXJsXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgR1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxHLCBbW0Jsb2IsIEJsb2JdXT59IEVuY29kZWRCbG9iQmxvYlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuPFQ+fSBUb2tlblR5cGVcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICogQGltcGxlbWVudHMge1Rva2VuVHlwZTxUPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DSURTdHJpbmd9IGlwbmZ0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yKGlwbmZ0LCB1cmwsIGRhdGEpIHtcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5pcG5mdCA9IGlwbmZ0XG4gICAgLyoqIEByZWFkb25seSAqL1xuICAgIHRoaXMudXJsID0gdXJsXG4gICAgLyoqIEByZWFkb25seSAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGFcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGlwbmZ0OiB7IGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgdXJsOiB7IGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiBmYWxzZSB9LFxuICAgICAgZGF0YTogeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgfSlcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn1cbiAgICovXG4gIGVtYmVkKCkge1xuICAgIHJldHVybiBUb2tlbi5lbWJlZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge3tkYXRhOiBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59fSB0b2tlblxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbQmxvYiwgVVJMXV0+fVxuICAgKi9cbiAgc3RhdGljIGVtYmVkKHsgZGF0YSB9KSB7XG4gICAgcmV0dXJuIGVtYmVkKGRhdGEsIHsgZ2F0ZXdheTogR0FURVdBWSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRva2VuIGlucHV0LCBlbmNvZGVzIGl0IGFzIGEgREFHLCB3cmFwcyBpdCBpbiBhIENBUiBhbmQgY3JlYXRlcyBhIG5ld1xuICAgKiBUb2tlbiBpbnN0YW5jZSBmcm9tIGl0LiBXaGVyZSB2YWx1ZXMgYXJlIGRpc2NvdmVyZWQgYEJsb2JgIChvciBgRmlsZWApXG4gICAqIG9iamVjdHMgaW4gdGhlIGdpdmVuIGlucHV0LCB0aGV5IGFyZSByZXBsYWNlZCB3aXRoIElQRlMgVVJMcyAoYW4gYGlwZnM6Ly9gXG4gICAqIHByZWZpeGVkIENJRCB3aXRoIGFuIG9wdGlvbmFsIHBhdGgpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjYXQgPSBuZXcgRmlsZShbJy4uLiddLCAnY2F0LnBuZycpXG4gICAqIGNvbnN0IGtpdHR5ID0gbmV3IEZpbGUoWycuLi4nXSwgJ2tpdHR5LnBuZycpXG4gICAqIGNvbnN0IHsgdG9rZW4sIGNhciB9ID0gYXdhaXQgVG9rZW4uZW5jb2RlKHtcbiAgICogICBuYW1lOiAnaGVsbG8nXG4gICAqICAgaW1hZ2U6IGNhdFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGV4dHJhOiB7XG4gICAqICAgICAgIGltYWdlOiBraXR0eVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY2lkOiBDSUQsIHRva2VuOiBUb2tlblR5cGU8VD4sIGNhcjogaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlKGlucHV0KSB7XG4gICAgY29uc3QgYmxvY2tzdG9yZSA9IG5ldyBCbG9ja3N0b3JlKClcbiAgICBjb25zdCBbYmxvYnMsIG1ldGFdID0gbWFwVG9rZW5JbnB1dEJsb2JzKGlucHV0KVxuICAgIC8qKiBAdHlwZSB7RW5jb2RlZEJsb2JVcmw8VD59ICovXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YSkpXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBDSURdXT59ICovXG4gICAgY29uc3QgZGFnID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhKSlcblxuICAgIGZvciAoY29uc3QgW2RvdFBhdGgsIGJsb2JdIG9mIGJsb2JzLmVudHJpZXMoKSkge1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgLy8gQHRzLWlnbm9yZSBibG9iIG1heSBiZSBhIEZpbGUhXG4gICAgICBjb25zdCBuYW1lID0gYmxvYi5uYW1lIHx8ICdibG9iJ1xuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vcGxhdGZvcm0uanMnKS5SZWFkYWJsZVN0cmVhbX0gKi9cbiAgICAgIGxldCBjb250ZW50XG4gICAgICAvLyBGSVhNRTogc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gYXdhaXQgYXJyYXlCdWZmZXIoKSFcbiAgICAgIC8vIE5vZGUuanMgMjAgaGFuZ3MgcmVhZGluZyB0aGUgc3RyZWFtIChpdCBuZXZlciBlbmRzKSBidXQgaW5cbiAgICAgIC8vIG9sZGVyIG5vZGUgdmVyc2lvbnMgYW5kIHRoZSBicm93c2VyIGl0IGlzIGZpbmUgdG8gdXNlIGJsb2Iuc3RyZWFtKCkuXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgICBpZiAocGFyc2VJbnQoZ2xvYmFsVGhpcy5wcm9jZXNzPy52ZXJzaW9ucz8ubm9kZSkgPiAxOCkge1xuICAgICAgICBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGJsb2Iuc3RyZWFtKClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgcm9vdDogY2lkIH0gPSBhd2FpdCBwYWNrKHtcbiAgICAgICAgaW5wdXQ6IFt7IHBhdGg6IG5hbWUsIGNvbnRlbnQgfV0sXG4gICAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgaHJlZiA9IG5ldyBVUkwoYGlwZnM6Ly8ke2NpZH0vJHtuYW1lfWApXG4gICAgICBjb25zdCBwYXRoID0gZG90UGF0aC5zcGxpdCgnLicpXG4gICAgICBzZXRJbihkYXRhLCBwYXRoLCBocmVmKVxuICAgICAgc2V0SW4oZGFnLCBwYXRoLCBjaWQpXG4gICAgfVxuXG4gICAgY29uc3QgeyByb290OiBtZXRhZGF0YUpzb25DaWQgfSA9IGF3YWl0IHBhY2soe1xuICAgICAgaW5wdXQ6IFt7IHBhdGg6ICdtZXRhZGF0YS5qc29uJywgY29udGVudDogSlNPTi5zdHJpbmdpZnkoZGF0YSkgfV0sXG4gICAgICBibG9ja3N0b3JlLFxuICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlLFxuICAgIH0pXG5cbiAgICBjb25zdCBibG9jayA9IGF3YWl0IEJsb2NrLmVuY29kZSh7XG4gICAgICB2YWx1ZToge1xuICAgICAgICAuLi5kYWcsXG4gICAgICAgICdtZXRhZGF0YS5qc29uJzogbWV0YWRhdGFKc29uQ2lkLFxuICAgICAgICB0eXBlOiAnbmZ0JyxcbiAgICAgIH0sXG4gICAgICBjb2RlYzogZGFnQ2JvcixcbiAgICAgIGhhc2hlcjogc2hhMjU2LFxuICAgIH0pXG4gICAgYXdhaXQgYmxvY2tzdG9yZS5wdXQoYmxvY2suY2lkLCBibG9jay5ieXRlcylcblxuICAgIHJldHVybiB7XG4gICAgICBjaWQ6IGJsb2NrLmNpZCxcbiAgICAgIHRva2VuOiBuZXcgVG9rZW4oXG4gICAgICAgIGJsb2NrLmNpZC50b1N0cmluZygpLFxuICAgICAgICBgaXBmczovLyR7YmxvY2suY2lkfS9tZXRhZGF0YS5qc29uYCxcbiAgICAgICAgZGF0YVxuICAgICAgKSxcbiAgICAgIGNhcjogbmV3IEJsb2Nrc3RvcmVDYXJSZWFkZXIoMSwgW2Jsb2NrLmNpZF0sIGJsb2Nrc3RvcmUpLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0VuY29kZWRCbG9iVXJsPFQ+fSBpbnB1dFxuICogQHBhcmFtIHtFbWJlZE9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFbmNvZGVkQmxvYlVybDxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVtYmVkID0gKGlucHV0LCBvcHRpb25zKSA9PlxuICBtYXBXaXRoKGlucHV0LCBpc1VSTCwgZW1iZWRVUkwsIG9wdGlvbnMpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZFRva2VuPFQ+fSB2YWx1ZVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gcGF0aHMgLSBQYXRocyB3ZXJlIHRvIGV4cGVjdCBFbmNvZGVkVVJMc1xuICogQHJldHVybnMge1Rva2VuPFQ+fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gKHsgaXBuZnQsIHVybCwgZGF0YSB9LCBwYXRocykgPT5cbiAgbmV3IFRva2VuKGlwbmZ0LCB1cmwsIG1hcFdpdGgoZGF0YSwgaXNFbmNvZGVkVVJMLCBkZWNvZGVVUkwsIHBhdGhzKSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBVUkx9XG4gKi9cbmNvbnN0IGlzVVJMID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFVSTFxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBTdGF0ZVxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVVJMfSB1cmxcbiAqIEByZXR1cm5zIHtbU3RhdGUsIFVSTF19XG4gKi9cbmNvbnN0IGRlY29kZVVSTCA9IChzdGF0ZSwgdXJsKSA9PiBbc3RhdGUsIG5ldyBVUkwodXJsKV1cblxuLyoqXG4gKiBAcGFyYW0ge0VtYmVkT3B0aW9uc30gY29udGV4dFxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHJldHVybnMge1tFbWJlZE9wdGlvbnMsIFVSTF19XG4gKi9cbmNvbnN0IGVtYmVkVVJMID0gKGNvbnRleHQsIHVybCkgPT4gW2NvbnRleHQsIHRvR2F0ZXdheVVSTCh1cmwsIGNvbnRleHQpXVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIG9iamVjdH1cbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT0gbnVsbFxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gYXNzZXRQYXRoc1xuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVVJMfVxuICovXG5jb25zdCBpc0VuY29kZWRVUkwgPSAodmFsdWUsIGFzc2V0UGF0aHMsIHBhdGgpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgYXNzZXRQYXRocy5oYXMocGF0aC5qb2luKCcuJykpXG5cbi8qKlxuICogVGFrZXMgdG9rZW4gaW5wdXQgYW5kIGVuY29kZXMgaXQgaW50b1xuICogW0Zvcm1EYXRhXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRm9ybURhdGEpXG4gKiBvYmplY3Qgd2hlcmUgZm9ybSBmaWVsZCB2YWx1ZXMgYXJlIGRpc2NvdmVyZWQgYEJsb2JgIChvciBgRmlsZWApIG9iamVjdHMgaW5cbiAqIHRoZSBnaXZlbiB0b2tlbiBhbmQgZmllbGQga2V5cyBhcmUgYC5gIGpvaW5lZCBwYXRocyB3aGVyZSB0aGV5IHdlcmUgZGlzY292ZXJkXG4gKiBpbiB0aGUgdG9rZW4uIEFkZGl0aW9uYWxseSBlbmNvZGVkIGBGb3JtRGF0YWAgd2lsbCBhbHNvIGhhdmUgYSBmaWVsZFxuICogbmFtZWQgYG1ldGFgIGNvbnRhaW5pbmcgSlNPTiBzZXJpYWxpemVkIHRva2VuIHdpdGggYmxvYnMgYW5kIGZpbGUgdmFsdWVzXG4gKiBgbnVsbGAgc2V0IHRvIG51bGwgKHRoaXMgYWxsb3dzIGJhY2tlbmQgdG8gaW5qZXN0IGFsbCBvZiB0aGUgZmlsZXMgZnJvbVxuICogYG11bHRpcGFydC9mb3JtLWRhdGFgIHJlcXVlc3QgYW5kIHVwZGF0ZSBwcm92aWRlZCBcIm1ldGFcIiBkYXRhIHdpdGhcbiAqIGNvcnJlc3BvbmRpbmcgZmlsZSBpcGZzOi8vIFVSTHMpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBjYXQgPSBuZXcgRmlsZShbXSwgJ2NhdC5wbmcnKVxuICogY29uc3Qga2l0dHkgPSBuZXcgRmlsZShbXSwgJ2tpdHR5LnBuZycpXG4gKiBjb25zdCBmb3JtID0gZW5jb2RlKHtcbiAqICAgbmFtZTogJ2hlbGxvJ1xuICogICBpbWFnZTogY2F0XG4gKiAgIHByb3BlcnRpZXM6IHtcbiAqICAgICBleHRyYToge1xuICogICAgICAgaW1hZ2U6IGtpdHR5XG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogWy4uLmZvcm0uZW50cmllcygpXSAvLz5cbiAqIC8vIFtcbiAqIC8vICAgWydpbWFnZScsIGNhdF0sXG4gKiAvLyAgIFsncHJvcGVydGllcy5leHRyYS5pbWFnZScsIGtpdHR5XSxcbiAqIC8vICAgWydtZXRhJywgJ3tcIm5hbWVcIjpcImhlbGxvXCIsaW1hZ2U6bnVsbCxcInByb3BlcnRpZXNcIjp7XCJleHRyYVwiOntcImtpdHR5XCI6IG51bGx9fX0nXVxuICogLy8gXVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAcGFyYW0ge0VuY29kZWRCbG9iQmxvYjxUPn0gaW5wdXRcbiAqIEByZXR1cm5zIHtGb3JtRGF0YX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IChpbnB1dCkgPT4ge1xuICBjb25zdCBbbWFwLCBtZXRhXSA9IG1hcFZhbHVlV2l0aChpbnB1dCwgaXNCbG9iLCBlbmNvZGVCbG9iLCBuZXcgTWFwKCksIFtdKVxuICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgIGZvcm0uc2V0KGssIHYpXG4gIH1cbiAgZm9ybS5zZXQoJ21ldGEnLCBKU09OLnN0cmluZ2lmeShtZXRhKSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIEJsb2I+fSBkYXRhXG4gKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aFxuICogQHJldHVybnMge1tNYXA8c3RyaW5nLCBCbG9iPiwgdm9pZF19XG4gKi9cbmNvbnN0IGVuY29kZUJsb2IgPSAoZGF0YSwgYmxvYiwgcGF0aCkgPT4ge1xuICBkYXRhLnNldChwYXRoLmpvaW4oJy4nKSwgYmxvYilcbiAgcmV0dXJuIFtkYXRhLCB1bmRlZmluZWRdXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgQmxvYn1cbiAqL1xuY29uc3QgaXNCbG9iID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JCbG9iPFQ+fSBpbnB1dFxuICovXG5jb25zdCBtYXBUb2tlbklucHV0QmxvYnMgPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIG1hcFZhbHVlV2l0aChpbnB1dCwgaXNCbG9iLCBlbmNvZGVCbG9iLCBuZXcgTWFwKCksIFtdKVxufVxuXG4vKipcbiAqIFN1YnN0aXR1ZXMgdmFsdWVzIGluIHRoZSBnaXZlbiBgaW5wdXRgIHRoYXQgbWF0Y2ggYHAodmFsdWUpID09IHRydWVgIHdpdGhcbiAqIGBmKHZhbHVlLCBjb250ZXh0LCBwYXRoKWAgd2hlcmUgYGNvbnRleHRgIGlzIHdoYXRldmVyIHlvdSBwYXNzICh1c3VhbGx5XG4gKiBhIG11dGFibGUgc3RhdGUpIGFuZCBgcGF0aGAgaXMgYSBhcnJheSBvZiBrZXlzIC8gaW5kZXhlcyB3aGVyZSB0aGUgdmFsdWVcbiAqIHdhcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBAdGVtcGxhdGUgVCwgSSwgWCwgTywgU3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgWF1dPn0gaW5wdXQgLSBBcmJpdHJhcnkgaW5wdXQuXG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHAgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB3aGljaCB2YWx1ZXMgdG8gc3dhcC5cbiAqIEBwYXJhbSB7KHN0YXRlOlN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGYgLSBGdW5jdGlvblxuICogdGhhdCBzd2FwcyBtYXRjaGluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSAtIFNvbWUgYWRkaXRpb25hbCBjb250ZXh0IHlvdSBuZWVkIGluIHRoZSBwcm9jZXNzLlxuICogbGlrZXkgeW91J2xsIHN0YXJ0IHdpdGggYFtdYC5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fVxuICovXG5leHBvcnQgY29uc3QgbWFwV2l0aCA9IChpbnB1dCwgcCwgZiwgc3RhdGUpID0+IHtcbiAgY29uc3QgWywgb3V0cHV0XSA9IG1hcFZhbHVlV2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIFtdKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsIEksIFgsIE8sIFN0YXRlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIFhdXT59IGlucHV0IC0gQXJiaXRyYXJ5IGlucHV0LlxuICogQHBhcmFtIHsoaW5wdXQ6YW55LCBzdGF0ZTpTdGF0ZSwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBpbnB1dCBpcyBYfSBwIC0gUHJlZGljYXRlIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogd2hpY2ggdmFsdWVzIHRvIHN3YXAuXG4gKiBAcGFyYW0geyhzdGF0ZTpTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmIC0gRnVuY3Rpb25cbiAqIHRoYXQgc3dhcHMgbWF0Y2hpbmcgdmFsdWVzLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGUgLSBTb21lIGFkZGl0aW9uYWwgY29udGV4dCB5b3UgbmVlZCBpbiB0aGUgcHJvY2Vzcy5cbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aCAtIFBhdGggd2hlcmUgdGhlIHZhbHVlIHdhcyBlbmNvdW50ZXJlZC4gTW9zdFxuICogbGlrZXkgeW91J2xsIHN0YXJ0IHdpdGggYFtdYC5cbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBWYWx1ZVdpdGggPSAoaW5wdXQsIHAsIGYsIHN0YXRlLCBwYXRoKSA9PlxuICBwKGlucHV0LCBzdGF0ZSwgcGF0aClcbiAgICA/IGYoc3RhdGUsIGlucHV0LCBwYXRoKVxuICAgIDogQXJyYXkuaXNBcnJheShpbnB1dClcbiAgICA/IG1hcEFycmF5V2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpXG4gICAgOiBpc09iamVjdChpbnB1dClcbiAgICA/IG1hcE9iamVjdFdpdGgoaW5wdXQsIHAsIGYsIHN0YXRlLCBwYXRoKVxuICAgIDogW3N0YXRlLCAvKiogQHR5cGUge2FueX0gKi8gKGlucHV0KV1cblxuLyoqXG4gKiBKdXN0IGxpa2UgYG1hcFdpdGhgIGV4Y2VwdFxuICpcbiAqIEB0ZW1wbGF0ZSBTdGF0ZSwgVCwgSSwgWCwgT1xuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBYXV0+fSBpbnB1dFxuICogQHBhcmFtIHsoaW5wdXQ6YW55LCBzdGF0ZTpTdGF0ZSwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBpbnB1dCBpcyBYfSBwXG4gKiBAcGFyYW0geyhzdGF0ZTogU3RhdGUsIGlucHV0OlgsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gW1N0YXRlLCBPXX0gZlxuICogQHBhcmFtIHtTdGF0ZX0gaW5pdFxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7W1N0YXRlLCBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+XX1cbiAqL1xuY29uc3QgbWFwT2JqZWN0V2l0aCA9IChpbnB1dCwgcCwgZiwgaW5pdCwgcGF0aCkgPT4ge1xuICBsZXQgc3RhdGUgPSBpbml0XG4gIGNvbnN0IG91dHB1dCA9XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fSAqLyAoe30pXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGlucHV0KSkge1xuICAgIGNvbnN0IFtuZXh0LCBvdXRdID0gbWFwVmFsdWVXaXRoKHZhbHVlLCBwLCBmLCBzdGF0ZSwgWy4uLnBhdGgsIGtleV0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG91dHB1dFtrZXldID0gb3V0XG4gICAgc3RhdGUgPSBuZXh0XG4gIH1cbiAgcmV0dXJuIFtzdGF0ZSwgb3V0cHV0XVxufVxuXG4vKipcbiAqIEp1c3QgbGlrZSBgbWFwV2l0aGAgZXhjZXB0IGZvciBBcnJheXMuXG4gKlxuICogQHRlbXBsYXRlIEksIFgsIE8sIFN0YXRlXG4gKiBAdGVtcGxhdGUge2FueVtdfSBUXG4gKiBAcGFyYW0ge1R9IGlucHV0XG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHBcbiAqIEBwYXJhbSB7KHN0YXRlOiBTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmXG4gKiBAcGFyYW0ge1N0YXRlfSBpbml0XG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBBcnJheVdpdGggPSAoaW5wdXQsIHAsIGYsIGluaXQsIHBhdGgpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gLyoqIEB0eXBlIHt1bmtub3duW119ICovIChbXSlcblxuICBsZXQgc3RhdGUgPSBpbml0XG4gIGZvciAoY29uc3QgW2luZGV4LCBlbGVtZW50XSBvZiBpbnB1dC5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBbbmV4dCwgb3V0XSA9IG1hcFZhbHVlV2l0aChlbGVtZW50LCBwLCBmLCBzdGF0ZSwgWy4uLnBhdGgsIGluZGV4XSlcbiAgICBvdXRwdXRbaW5kZXhdID0gb3V0XG4gICAgc3RhdGUgPSBuZXh0XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHN0YXRlLFxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPn0gKi8gKG91dHB1dCksXG4gIF1cbn1cblxuLyoqXG4gKiBTZXRzIGEgZ2l2ZW4gYHZhbHVlYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgIG9uIGEgcGFzc2VkIGBvYmplY3RgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3Qgb2JqID0geyBhOiB7IGI6IHsgYzogMSB9fX1cbiAqIHNldEluKG9iaiwgWydhJywgJ2InLCAnYyddLCA1KVxuICogb2JqLmEuYi5jIC8vPiA1XG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aFxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICovXG5jb25zdCBzZXRJbiA9IChvYmplY3QsIHBhdGgsIHZhbHVlKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXRoLmxlbmd0aCAtIDFcbiAgbGV0IHRhcmdldCA9IG9iamVjdFxuICBmb3IgKGxldCBbaW5kZXgsIGtleV0gb2YgcGF0aC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoaW5kZXggPT09IG4pIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nft.storage/src/token.js\n");

/***/ })

};
;
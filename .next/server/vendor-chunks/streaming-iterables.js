"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/streaming-iterables";
exports.ids = ["vendor-chunks/streaming-iterables"];
exports.modules = {

/***/ "(ssr)/./node_modules/streaming-iterables/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/streaming-iterables/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   batchWithTimeout: () => (/* binding */ batchWithTimeout),\n/* harmony export */   buffer: () => (/* binding */ buffer),\n/* harmony export */   collect: () => (/* binding */ collect),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   consume: () => (/* binding */ consume),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   flatMap: () => (/* binding */ flatMap),\n/* harmony export */   flatTransform: () => (/* binding */ flatTransform),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   fromStream: () => (/* binding */ fromStream),\n/* harmony export */   getIterator: () => (/* binding */ getIterator),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   parallelFlatMap: () => (/* binding */ parallelFlatMap),\n/* harmony export */   parallelMap: () => (/* binding */ parallelMap),\n/* harmony export */   parallelMerge: () => (/* binding */ parallelMerge),\n/* harmony export */   pipeline: () => (/* binding */ pipeline),\n/* harmony export */   reduce: () => (/* binding */ reduce),\n/* harmony export */   take: () => (/* binding */ take),\n/* harmony export */   tap: () => (/* binding */ tap),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   time: () => (/* binding */ time),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   writeToStream: () => (/* binding */ writeToStream)\n/* harmony export */ });\nasync function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - time;\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RyZWFtaW5nLWl0ZXJhYmxlcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kLW1hbmRhdGVzLy4vbm9kZV9tb2R1bGVzL3N0cmVhbWluZy1pdGVyYWJsZXMvZGlzdC9pbmRleC5tanM/ZjU4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJhc3luYyBmdW5jdGlvbiogX2JhdGNoKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgbGV0IGRhdGFCYXRjaCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBkYXRhQmF0Y2gucHVzaChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGFCYXRjaC5sZW5ndGggPT09IHNpemUpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGFCYXRjaDtcbiAgICAgICAgICAgIGRhdGFCYXRjaCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhQmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCBkYXRhQmF0Y2g7XG4gICAgfVxufVxuZnVuY3Rpb24qIF9zeW5jQmF0Y2goc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBsZXQgZGF0YUJhdGNoID0gW107XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGRhdGFCYXRjaC5wdXNoKGRhdGEpO1xuICAgICAgICBpZiAoZGF0YUJhdGNoLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgeWllbGQgZGF0YUJhdGNoO1xuICAgICAgICAgICAgZGF0YUJhdGNoID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGFCYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGRhdGFCYXRjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXRjaChzaXplLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gYmF0Y2goc2l6ZSwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2JhdGNoKHNpemUsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9zeW5jQmF0Y2goc2l6ZSwgaXRlcmFibGUpO1xufVxuXG5jb25zdCBUSU1FT1VUID0gU3ltYm9sKCdUSU1FT1VUJyk7XG5jb25zdCBjcmVhdGVUaW1lciA9IChkdXJhdGlvbikgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoVElNRU9VVCksIGR1cmF0aW9uKTtcbiAgICAgICAgfSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9LFxuICAgIF07XG59O1xuLy8gTGlrZSBgYmF0Y2hgIGJ1dCBmbHVzaGVzIGVhcmx5IGlmIHRoZSBgdGltZW91dGAgaXMgcmVhY2hlZFxuLy8gTk9URTogVGhlIHN0cmF0ZWd5IGlzIHRvIG9ubHkgaG9sZCBvbnRvIGEgc2luZ2xlIGl0ZW0gZm9yIGEgbWF4aW11bSBvZiBgdGltZW91dGAgbXMuXG5hc3luYyBmdW5jdGlvbiogX2JhdGNoV2l0aFRpbWVvdXQoc2l6ZSwgdGltZW91dCwgaXRlcmFibGUpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCBwZW5kaW5nRGF0YTtcbiAgICBsZXQgYmF0Y2hEYXRhID0gW107XG4gICAgbGV0IHRpbWVyO1xuICAgIGxldCBjbGVhclRpbWVyO1xuICAgIGNvbnN0IHN0YXJ0VGltZXIgPSAoKSA9PiB7XG4gICAgICAgIGRlbGV0ZVRpbWVyKCk7XG4gICAgICAgIFt0aW1lciwgY2xlYXJUaW1lcl0gPSBjcmVhdGVUaW1lcih0aW1lb3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVRpbWVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY2xlYXJUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcGVuZGluZ0RhdGEgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKHRpbWVyID8gUHJvbWlzZS5yYWNlKFtwZW5kaW5nRGF0YSwgdGltZXJdKSA6IHBlbmRpbmdEYXRhKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gVElNRU9VVCB8fCByZXMuZG9uZSkge1xuICAgICAgICAgICAgLy8gRmx1c2ggZWFybHkgKGJlZm9yZSB3ZSByZWFjaCB0aGUgYmF0Y2ggc2l6ZSlcbiAgICAgICAgICAgIGlmIChiYXRjaERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgYmF0Y2hEYXRhO1xuICAgICAgICAgICAgICAgIGJhdGNoRGF0YSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlVGltZXIoKTtcbiAgICAgICAgICAgIC8vIEFuZCBleGl0IGFwcHJvcHJpYXRlbHlcbiAgICAgICAgICAgIGlmIChyZXMgIT09IFRJTUVPVVQpIHtcbiAgICAgICAgICAgICAgICAvLyBkb25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBuZXh0IGl0ZW0gZWFybHkgZG9vcnMgKGJlZm9yZSB3ZSBwb3RlbnRpYWxseSB5aWVsZClcbiAgICAgICAgcGVuZGluZ0RhdGEgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8vIFRoZW4gaGFuZGxlIHRoZSB2YWx1ZVxuICAgICAgICBiYXRjaERhdGEucHVzaChyZXMudmFsdWUpO1xuICAgICAgICBpZiAoYmF0Y2hEYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gU3RhcnQgdGltZXIgb25jZSB3ZSBoYXZlIGF0IGxlYXN0IDEgaXRlbSByZWFkeSB0byBnb1xuICAgICAgICAgICAgc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaERhdGEubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgICAgICB5aWVsZCBiYXRjaERhdGE7XG4gICAgICAgICAgICBiYXRjaERhdGEgPSBbXTtcbiAgICAgICAgICAgIGRlbGV0ZVRpbWVyKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJhdGNoV2l0aFRpbWVvdXQoc2l6ZSwgdGltZW91dCwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGJhdGNoV2l0aFRpbWVvdXQoc2l6ZSwgdGltZW91dCwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAmJiB0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gX2JhdGNoV2l0aFRpbWVvdXQoc2l6ZSwgdGltZW91dCwgaXRlcmFibGUpO1xuICAgIH1cbiAgICAvLyBGb3Igc3luYyBpdGVyYWJsZXMgb3IgYW4gaW5maW5pdGUgdGltZW91dCwgdGhlIHRpbWVvdXQgaXMgaXJyZWxldmFudCBzbyBqdXN0IGZhbGxiYWNrIHRvIHJlZ3VsYXIgYGJhdGNoYC5cbiAgICByZXR1cm4gYmF0Y2goc2l6ZSwgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVzXCIgZG9lcyBub3QgdG8gY29uZm9ybSB0byBhbnkgb2YgdGhlIGl0ZXJhdG9yIG9yIGl0ZXJhYmxlIHByb3RvY29scycpO1xufVxuXG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZUZ1bmMsIHJlamVjdEZ1bmMpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlc29sdmVGdW5jO1xuICAgICAgICByZWplY3QgPSByZWplY3RGdW5jO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIHJlamVjdCxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfYnVmZmVyKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgY29uc3QgcmVzdWx0UXVldWUgPSBbXTtcbiAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxSZWFkUXVldWUoKSB7XG4gICAgICAgIHdoaWxlIChyZWFkUXVldWUubGVuZ3RoID4gMCAmJiByZXN1bHRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkRGVmZXJyZWQgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IsIHZhbHVlIH0gPSByZXN1bHRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVhZERlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWFkRGVmZXJyZWQucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmVhZFF1ZXVlLmxlbmd0aCA+IDAgJiYgZW5kZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmaWxsUXVldWUoKSB7XG4gICAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFF1ZXVlLmxlbmd0aCA+PSBzaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFF1ZXVlLnB1c2goeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdFF1ZXVlLnB1c2goeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChyZXN1bHRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yLCB2YWx1ZSB9ID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTsgLy8gc3R1cGlkIHRzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICByZWFkUXVldWUucHVzaChkZWZlcnJlZCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgYXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBhc3luY0l0ZXJhYmxlSXRlcmF0b3IsXG4gICAgfTtcbiAgICByZXR1cm4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yO1xufVxuZnVuY3Rpb24qIHN5bmNCdWZmZXIoc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBjb25zdCB2YWx1ZVF1ZXVlID0gW107XG4gICAgbGV0IGU7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgdmFsdWVRdWV1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVF1ZXVlLmxlbmd0aCA8PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSBlcnJvcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZVF1ZXVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gYnVmZmVyKHNpemUsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2J1ZmZlcihzaXplLCBpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBzeW5jQnVmZmVyKHNpemUsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2NvbGxlY3QoaXRlcmFibGUpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGNvbGxlY3QoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBfY29sbGVjdChpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIF9jb25jYXQoaXRlcmFibGVzKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcbiAgICAgICAgeWllbGQqIGl0ZXJhYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uKiBfc3luY0NvbmNhdChpdGVyYWJsZXMpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZXJhYmxlIG9mIGl0ZXJhYmxlcykge1xuICAgICAgICB5aWVsZCogaXRlcmFibGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uY2F0KC4uLml0ZXJhYmxlcykge1xuICAgIGNvbnN0IGhhc0FueUFzeW5jID0gaXRlcmFibGVzLmZpbmQoaXRyID0+IGl0cltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gIT09IHVuZGVmaW5lZCk7XG4gICAgaWYgKGhhc0FueUFzeW5jKSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KGl0ZXJhYmxlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX3N5bmNDb25jYXQoaXRlcmFibGVzKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9jb25zdW1lKGl0ZXJhYmxlKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnN1bWUoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBfY29uc3VtZShpdGVyYWJsZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfZmlsdGVyKGZpbHRlckZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBkYXRhIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChhd2FpdCBmaWx0ZXJGdW5jKGRhdGEpKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmlsdGVyKGZpbHRlckZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IF9maWx0ZXIoZmlsdGVyRnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9maWx0ZXIoZmlsdGVyRnVuYywgaXRlcmFibGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiogZmxhdHRlbihpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWF5YmVJdHIgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgaWYgKG1heWJlSXRyICYmIHR5cGVvZiBtYXliZUl0ciAhPT0gJ3N0cmluZycgJiYgKG1heWJlSXRyW1N5bWJvbC5pdGVyYXRvcl0gfHwgbWF5YmVJdHJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSkge1xuICAgICAgICAgICAgeWllbGQqIGZsYXR0ZW4obWF5YmVJdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgbWF5YmVJdHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfbWFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgeWllbGQgYXdhaXQgZnVuYyh2YWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gX21hcChmdW5jLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX21hcChmdW5jLCBpdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGZsYXRNYXAoZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcihpID0+IGkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBudWxsLCBmbGF0dGVuKG1hcChmdW5jLCBpdGVyYWJsZSkpKTtcbn1cblxuZnVuY3Rpb24gX2ZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgY29uc3QgcmVzdWx0UXVldWUgPSBbXTtcbiAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBpbmZsaWdodENvdW50ID0gMDtcbiAgICBsZXQgbGFzdEVycm9yID0gbnVsbDtcbiAgICBmdW5jdGlvbiBmdWxmaWxsUmVhZFF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAocmVhZFF1ZXVlLmxlbmd0aCA+IDAgJiYgcmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyByZXNvbHZlIH0gPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIGluZmxpZ2h0Q291bnQgPT09IDAgJiYgZW5kZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmlsbFF1ZXVlKCkge1xuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIGZ1bGZpbGxSZWFkUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZsaWdodENvdW50ICsgcmVzdWx0UXVldWUubGVuZ3RoID49IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgIGluZmxpZ2h0Q291bnQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBBbmRRdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGZ1bGZpbGxSZWFkUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtYXBBbmRRdWV1ZShpdHJWYWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBmdW5jKGl0clZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGFzeW5jVmFsIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFF1ZXVlLnB1c2goYXN5bmNWYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFF1ZXVlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAocmVzdWx0UXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgICAgICByZWFkUXVldWUucHVzaChkZWZlcnJlZCk7XG4gICAgICAgICAgICBmaWxsUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCBhc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQsXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06ICgpID0+IGFzeW5jSXRlcmFibGVJdGVyYXRvcixcbiAgICB9O1xuICAgIHJldHVybiBhc3luY0l0ZXJhYmxlSXRlcmF0b3I7XG59XG5mdW5jdGlvbiBmbGF0VHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKSA9PiBjdXJyaWVkSXRlcmFibGVcbiAgICAgICAgICAgID8gZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSlcbiAgICAgICAgICAgIDogZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcihpID0+IGkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBudWxsLCBmbGF0dGVuKF9mbGF0VHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25jZVJlYWRhYmxlKHN0cmVhbSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc3RyZWFtLm9uY2UoJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBfZnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gc3RyZWFtLnJlYWQoKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBvbmNlUmVhZGFibGUoc3RyZWFtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tU3RyZWFtKHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICByZXR1cm4gX2Zyb21TdHJlYW0oc3RyZWFtKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIG1lcmdlKC4uLml0ZXJhYmxlcykge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBuZXcgU2V0KGl0ZXJhYmxlcy5tYXAoZ2V0SXRlcmF0b3IpKTtcbiAgICB3aGlsZSAoc291cmNlcy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRWYWwgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dFZhbC5kb25lKSB7XG4gICAgICAgICAgICAgICAgc291cmNlcy5kZWxldGUoaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgbmV4dFZhbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoZmlyc3RGbiwgLi4uZm5zKSB7XG4gICAgbGV0IHByZXZpb3VzRm4gPSBmaXJzdEZuKCk7XG4gICAgZm9yIChjb25zdCBmdW5jIG9mIGZucykge1xuICAgICAgICBwcmV2aW91c0ZuID0gZnVuYyhwcmV2aW91c0ZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzRm47XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfcGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgbGV0IHRyYW5zZm9ybUVycm9yID0gbnVsbDtcbiAgICBjb25zdCB3cmFwRnVuYyA9IHZhbHVlID0+ICh7XG4gICAgICAgIHZhbHVlOiBmdW5jKHZhbHVlKSxcbiAgICB9KTtcbiAgICBjb25zdCBzdG9wT25FcnJvciA9IGFzeW5jIGZ1bmN0aW9uKiAoc291cmNlKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0ID0gcGlwZWxpbmUoKCkgPT4gaXRlcmFibGUsIGJ1ZmZlcigxKSwgc3RvcE9uRXJyb3IsIG1hcCh3cmFwRnVuYyksIGJ1ZmZlcihjb25jdXJyZW5jeSAtIDEpKTtcbiAgICBjb25zdCBpdHIgPSBnZXRJdGVyYXRvcihvdXRwdXQpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ci5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gYXdhaXQgdmFsdWUudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybUVycm9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJhbnNmb3JtRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdHJhbnNmb3JtRXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpID0+IHBhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiBwYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKGNvbmN1cnJlbmN5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBtYXAoZnVuYywgaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3BhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIHBhcmFsbGVsRmxhdE1hcChjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSkgPT4gY3VycmllZEl0ZXJhYmxlXG4gICAgICAgICAgICA/IHBhcmFsbGVsRmxhdE1hcChjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSlcbiAgICAgICAgICAgIDogcGFyYWxsZWxGbGF0TWFwKGNvbmN1cnJlbmN5LCBjdXJyaWVkRnVuYyk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBwYXJhbGxlbEZsYXRNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIoaSA9PiBpICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gbnVsbCwgZmxhdHRlbihwYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBwYXJhbGxlbE1lcmdlKC4uLml0ZXJhYmxlcykge1xuICAgIGNvbnN0IGlucHV0cyA9IGl0ZXJhYmxlcy5tYXAoZ2V0SXRlcmF0b3IpO1xuICAgIGNvbnN0IGNvbmN1cnJlbnRXb3JrID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgbGFzdEVycm9yID0gbnVsbDtcbiAgICBsZXQgZXJyQ2IgPSBudWxsO1xuICAgIGxldCB2YWx1ZUNiID0gbnVsbDtcbiAgICBjb25zdCBub3RpZnlFcnJvciA9IGVyciA9PiB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgaWYgKGVyckNiKSB7XG4gICAgICAgICAgICBlcnJDYihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3RpZnlEb25lID0gdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWVDYikge1xuICAgICAgICAgICAgdmFsdWVDYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdhaXRGb3JRdWV1ZSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUNiID0gcmVzb2x2ZTtcbiAgICAgICAgZXJyQ2IgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcXVldWVOZXh0ID0gaW5wdXQgPT4ge1xuICAgICAgICBjb25zdCBuZXh0VmFsID0gUHJvbWlzZS5yZXNvbHZlKGlucHV0Lm5leHQoKSkudGhlbihhc3luYyAoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KGlucHV0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25jdXJyZW50V29yay5kZWxldGUobmV4dFZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25jdXJyZW50V29yay5hZGQobmV4dFZhbCk7XG4gICAgICAgIG5leHRWYWwudGhlbihub3RpZnlEb25lLCBub3RpZnlFcnJvcik7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICBxdWV1ZU5leHQoaW5wdXQpO1xuICAgIH1cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBXZSB0ZWNobmljYWxseSBkb24ndCBoYXZlIHRvIGNoZWNrIGB2YWx1ZXMuc2l6ZWAgYXMgdGhlIGZvciBsb29wIHNob3VsZCBoYXZlIGVtcHRpZWQgaXRcbiAgICAgICAgLy8gSG93ZXZlciBJIGhhdmVuJ3QgeWV0IGZvdW5kIHNwZWNzIHZlcmlmeWluZyB0aGF0IGJlaGF2aW9yLCBvbmx5IHRlc3RzXG4gICAgICAgIC8vIHRoZSBndWFyZCBpbiB3YWl0Rm9yUXVldWUoKSBjaGVja2luZyBmb3IgdmFsdWVzIGlzIGluIHBsYWNlIGZvciB0aGUgc2FtZSByZWFzb25cbiAgICAgICAgaWYgKGNvbmN1cnJlbnRXb3JrLnNpemUgPT09IDAgJiYgdmFsdWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB3YWl0Rm9yUXVldWUoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5wdXQsIHZhbHVlXSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhbHVlcy5kZWxldGUoaW5wdXQpO1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgICAgICBxdWV1ZU5leHQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfcmVkdWNlKGZ1bmMsIHN0YXJ0LCBpdGVyYWJsZSkge1xuICAgIGxldCB2YWx1ZSA9IHN0YXJ0O1xuICAgIGZvciBhd2FpdCAoY29uc3QgbmV4dEl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgdmFsdWUgPSBhd2FpdCBmdW5jKHZhbHVlLCBuZXh0SXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlZHVjZShmdW5jLCBzdGFydCwgaXRlcmFibGUpIHtcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRTdGFydCwgY3VycmllZEl0ZXJhYmxlKSA9PiBjdXJyaWVkSXRlcmFibGUgPyBfcmVkdWNlKGZ1bmMsIGN1cnJpZWRTdGFydCwgY3VycmllZEl0ZXJhYmxlKSA6IHJlZHVjZShmdW5jLCBjdXJyaWVkU3RhcnQpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gcmVkdWNlKGZ1bmMsIHN0YXJ0LCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3JlZHVjZShmdW5jLCBzdGFydCwgaXRlcmFibGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiogX3Rha2UoY291bnQsIGl0ZXJhYmxlKSB7XG4gICAgbGV0IHRha2VuID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICB5aWVsZCBhd2FpdCB2YWw7XG4gICAgICAgIHRha2VuKys7XG4gICAgICAgIGlmICh0YWtlbiA+PSBjb3VudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiogX3N5bmNUYWtlKGNvdW50LCBpdGVyYWJsZSkge1xuICAgIGxldCB0YWtlbiA9IDA7XG4gICAgZm9yIChjb25zdCB2YWwgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgeWllbGQgdmFsO1xuICAgICAgICB0YWtlbisrO1xuICAgICAgICBpZiAodGFrZW4gPj0gY291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGFrZShjb3VudCwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IHRha2UoY291bnQsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIF90YWtlKGNvdW50LCBpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfc3luY1Rha2UoY291bnQsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIF9hc3luY1RhcChmdW5jLCBpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGF3YWl0IGZ1bmModmFsKTtcbiAgICAgICAgeWllbGQgdmFsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRhcChmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBfYXN5bmNUYXAoZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9hc3luY1RhcChmdW5jLCBpdGVyYWJsZSk7XG59XG5cbmNvbnN0IHNsZWVwID0gKG1zKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbmZ1bmN0aW9uIF90aHJvdHRsZShsaW1pdCwgaW50ZXJ2YWwsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBsaW1pdGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBsaW1pdGAgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW50ZXJ2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBpbnRlcnZhbGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24qIF9fdGhyb3R0bGUoKSB7XG4gICAgICAgIGxldCBzZW50ID0gMDtcbiAgICAgICAgbGV0IHRpbWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAoc2VudCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VudCsrO1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgd2FpdCBpZiB0aGUgaW50ZXJ2YWwgaGFzbid0IGFscmVhZHkgcGFzc2VkIHdoaWxlIHdlIHdlcmVcbiAgICAgICAgICAgIC8vIHlpZWxkaW5nIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkTXMgPSBEYXRlLm5vdygpIC0gdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHdhaXRGb3IgPSBpbnRlcnZhbCAtIGVsYXBzZWRNcztcbiAgICAgICAgICAgIGlmICh3YWl0Rm9yID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHdhaXRGb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBzZW50ID0gMTtcbiAgICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgfVxuICAgIH0pKCk7XG59XG5mdW5jdGlvbiB0aHJvdHRsZShsaW1pdCwgaW50ZXJ2YWwsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IF90aHJvdHRsZShsaW1pdCwgaW50ZXJ2YWwsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBpdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWUoYSwgYikge1xuICAgIGxldCBzZWNvbmRzID0gYVswXSArIGJbMF07XG4gICAgbGV0IG5hbm9zZWNvbmRzID0gYVsxXSArIGJbMV07XG4gICAgaWYgKG5hbm9zZWNvbmRzID49IDEwMDAwMDAwMDApIHtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyID0gbmFub3NlY29uZHMgJSAxMDAwMDAwMDAwO1xuICAgICAgICBzZWNvbmRzICs9IChuYW5vc2Vjb25kcyAtIHJlbWFpbmRlcikgLyAxMDAwMDAwMDAwO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IHJlbWFpbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc2Vjb25kc107XG59XG5hc3luYyBmdW5jdGlvbiogX2FzeW5jVGltZShjb25maWcsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRyID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgbGV0IHRvdGFsID0gWzAsIDBdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRyLm5leHQoKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwcm9jZXNzLmhydGltZShzdGFydCk7XG4gICAgICAgIHRvdGFsID0gYWRkVGltZSh0b3RhbCwgZGVsdGEpO1xuICAgICAgICBpZiAoY29uZmlnLnByb2dyZXNzKSB7XG4gICAgICAgICAgICBjb25maWcucHJvZ3Jlc3MoZGVsdGEsIHRvdGFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy50b3RhbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50b3RhbCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24qIF9zeW5jVGltZShjb25maWcsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRyID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGxldCB0b3RhbCA9IFswLCAwXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGl0ci5uZXh0KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnQpO1xuICAgICAgICB0b3RhbCA9IGFkZFRpbWUodG90YWwsIGRlbHRhKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY29uZmlnLnByb2dyZXNzKGRlbHRhLCB0b3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcudG90YWwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcudG90YWwodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpbWUoY29uZmlnID0ge30sIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiB0aW1lKGNvbmZpZywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfYXN5bmNUaW1lKGNvbmZpZywgaXRlcmFibGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zeW5jVGltZShjb25maWcsIGl0ZXJhYmxlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF90cmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgY29uc3QgcmVzdWx0UXVldWUgPSBbXTtcbiAgICBjb25zdCByZWFkUXVldWUgPSBbXTtcbiAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBpbmZsaWdodENvdW50ID0gMDtcbiAgICBsZXQgbGFzdEVycm9yID0gbnVsbDtcbiAgICBmdW5jdGlvbiBmdWxmaWxsUmVhZFF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAocmVhZFF1ZXVlLmxlbmd0aCA+IDAgJiYgcmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyByZXNvbHZlIH0gPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIGluZmxpZ2h0Q291bnQgPT09IDAgJiYgZW5kZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmlsbFF1ZXVlKCkge1xuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIGZ1bGZpbGxSZWFkUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZsaWdodENvdW50ICsgcmVzdWx0UXVldWUubGVuZ3RoID49IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgIGluZmxpZ2h0Q291bnQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBBbmRRdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGZ1bGZpbGxSZWFkUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtYXBBbmRRdWV1ZShpdHJWYWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBmdW5jKGl0clZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdFF1ZXVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAocmVzdWx0UXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgICAgICByZWFkUXVldWUucHVzaChkZWZlcnJlZCk7XG4gICAgICAgICAgICBmaWxsUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCBhc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQsXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06ICgpID0+IGFzeW5jSXRlcmFibGVJdGVyYXRvcixcbiAgICB9O1xuICAgIHJldHVybiBhc3luY0l0ZXJhYmxlSXRlcmF0b3I7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpID0+IGN1cnJpZWRJdGVyYWJsZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpXG4gICAgICAgICAgICA6IHRyYW5zZm9ybShjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3RyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVUb1N0cmVhbShzdHJlYW0sIGl0ZXJhYmxlKSB7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgbGV0IGVyckNiID0gbnVsbDtcbiAgICBsZXQgZHJhaW5DYiA9IG51bGw7XG4gICAgY29uc3Qgbm90aWZ5RXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgIGlmIChlcnJDYikge1xuICAgICAgICAgICAgZXJyQ2IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm90aWZ5RHJhaW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChkcmFpbkNiKSB7XG4gICAgICAgICAgICBkcmFpbkNiKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBub3RpZnlFcnJvcik7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBub3RpZnlEcmFpbik7XG4gICAgfTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub3RpZnlFcnJvcik7XG4gICAgY29uc3Qgd2FpdEZvckRyYWluID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLm9uY2UoJ2RyYWluJywgbm90aWZ5RHJhaW4pO1xuICAgICAgICBkcmFpbkNiID0gcmVzb2x2ZTtcbiAgICAgICAgZXJyQ2IgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBpZiAoc3RyZWFtLndyaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cml0ZVRvU3RyZWFtKHN0cmVhbSwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gX3dyaXRlVG9TdHJlYW0oc3RyZWFtLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3dyaXRlVG9TdHJlYW0oc3RyZWFtLCBpdGVyYWJsZSk7XG59XG5cbmV4cG9ydCB7IGJhdGNoLCBiYXRjaFdpdGhUaW1lb3V0LCBidWZmZXIsIGNvbGxlY3QsIGNvbmNhdCwgY29uc3VtZSwgZmlsdGVyLCBmbGF0TWFwLCBmbGF0VHJhbnNmb3JtLCBmbGF0dGVuLCBmcm9tU3RyZWFtLCBnZXRJdGVyYXRvciwgbWFwLCBtZXJnZSwgcGFyYWxsZWxGbGF0TWFwLCBwYXJhbGxlbE1hcCwgcGFyYWxsZWxNZXJnZSwgcGlwZWxpbmUsIHJlZHVjZSwgdGFrZSwgdGFwLCB0aHJvdHRsZSwgdGltZSwgdHJhbnNmb3JtLCB3cml0ZVRvU3RyZWFtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/streaming-iterables/dist/index.mjs\n");

/***/ })

};
;